<html>
<head>
<!-- This file has been generated by unroff 1.0, 03/17/98 10:03:32. -->
<!-- Do not edit! -->
<title>2.11BSD Setup</title>
</head><body>
<!--  Copyright (c) 1980 Regents of the University of California. -->
<!--  All rights reserved.  The Berkeley software License Agreement -->
<!--  specifies the terms and conditions for redistribution. -->
<!-- 	@(#)0.t	2.3 (GTE) 1995/06/13 -->
<h1>
Installing and Operating 2.11BSD on the PDP-11
<br>
June 13, 1995
</h1>
<p>
<i><center>Steven Schultz
<br>
</i><center>GTE Government Systems
112 Lakeview Canyon
Thousand Oaks CA 91362
sms@wlv.iipo.gtegsc.com
</center>
<hr>
<h2>ABSTRACT</h2>
<p>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>This document contains instructions for the
installation and operation of the 2.11BSD PDP-11\(ua
UNIX***
system.<tt> </tt>
</dl>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>It discusses procedures for installing 2.11BSD UNIX on a PDP-11, including
explanations of how to lay out file systems on available disks, how to set
up terminal lines and user accounts, how to do system-specific tailoring,
and how to install and configure the networking facilities.  Finally, the
document details system operation procedures: shutdown and startup,
hardware error reporting and diagnosis, file system backup procedures,
resource control, performance monitoring, and procedures for recompiling
and reinstalling system software.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>The ``bugs'' address supplied with this release
will work for some unknown period of time; make sure
the ``Index:'' line of the bug report indicates that the release is
``2.11BSD''.  See the <i>sendbug</i>(8) program for more details.  All
fixes that I make, or that are sent to me, will be posted on
<i>USENET</i>, in the news group ``comp.bugs.2bsd''.<tt> </tt>
<hr>
<!--  Copyright (c) 1980 Regents of the University of California. -->
<!--  All rights reserved.  The Berkeley software License Agreement -->
<!--  specifies the terms and conditions for redistribution. -->
<!-- 	@(#)1.t	2.5 (GTE) 1997/1/24 -->
<p>
<br>
<b>
</b><b><center>1. INTRODUCTION
<br>
</center>
</b><b></b><p>
<p>
<b></b>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>This document explains how to install 2.11BSD UNIX for the PDP-11 on your
system.  This document has been revised several times since the first
release of 2.11BSD, most recently in July 1995 to reflect the addition of disk
labels to the system.  The format of the bootable tape has changed. 
There is now a standalone
<b>disklabel
</b>program present.<tt> </tt>
While the system call interface is the same
as that of 2.10.1BSD,
a full bootstrap from the distribution tape is required because the
filesystem has changed to allow file names longer than 14 characters.<tt> </tt>
Also, the 3 byte block number packing scheme used by earlier versions
of UNIX for the PDP-11 has been eliminated.  Block numbers are always 4 byte
<b>longs</b> now.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>The procedure for performing a full bootstrap is outlined in chapter 2.<tt> </tt>
The process includes copying a root file system from
the distribution tape into a new file system,
booting that root filesystem, and then reading the remainder of the system
binaries and sources from the archives on the tapes.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>As 2.11BSD is not compatible at the filesystem level with previous versions
of UNIX on the PDP-11,
any upgrade procedure is essentially a full bootstrap.  There is a
limited ability to access old filesystems which may be used after
the system partitions have been loaded from a full bootstrap.<tt> </tt>
It is desirable to recompile most local software after the conversion,
as there are changes and performance improvements in the standard
libraries.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>Binaries from 2.10.1BSD which do not read directories or inode structures
may be used but should be recompiled to pick up changes in the standard
libraries.  Note too, that the portable ASCII format of <i>ar</i>(1) archives
is now in place - any local archive files will have to be converted using
<i>/usr/old/arcv</i>.<tt> </tt>
<h2>1.&#160;<tt> </tt>Hardware supported
</h2>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>This distribution can be booted on a PDP-11
with 1Mb of memory or more\(ua,
separate I&amp;D, and with any of the following disks:
<dl><dt><dd>
RK06, RK07
Any MSCP disk, including but not limited to: RD53, RD54, RA81, RZ2x
RM03, RM05
RP04, RP05, RP06
Many other SMD disks, for example: CDC 9766, Fuji 160, Fuji Eagle
</dl>
</dl>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>Other disks are supported (RX23, RX33, RX50, RD51) but are not large
enough to hold a root filesystem plus a swap partition.  The old restriction
of using RL02 drives in pairs has been lifted.  It is now possible to define
a root ('a') partition and a swap partition ('b') and load at least the
root filesystem to a single RL02.<tt> </tt>
Discs which are too small to hold even a root filesystem (floppies for 
example)
may be used as data disks or as standalone boot media, but are not useable
for loading the distribution.  Others, while listed above, are not very
well suited to loading the distribution.  The RK06/07 drives are hard pressed
to even hold the system binaries, much less the sources.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>The tape drives supported by this distribution are:
<dl><dt><dd>
TS11, TU80, TK25
TM11, AVIV 6250/1600
TE16, TU45, TU77
TK50, TU81, TU81+, TZ30
</dl>
Although 2.11BSD contains a kernel level floating point simulator, it has
never been tested.  In fact it would not even compile/assemble without
errors!  That problem has been fixed but it is still not know if the
simulator works, KDJ-11 based systems have builtin floating point so the
simulator can not be tested.  At the release of 2.10BSD some thought was given
to the possibility of lifting the separate I&amp;D restriction, but that
thought has languished.  The work will
never be done.  As time passes more and more programs have
become almost too large even with separate I&amp;D.<tt> </tt>
<h2>2.&#160;<tt> </tt>Distribution format
</h2>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>The basic distribution contains the following items:
<dl><dt><dd>
(2)   1600bpi 2400' magnetic tapes, or
<br>
(2)   TK25 tape cartridges, or
<br>
(1)   TK50 tape cartridge, and
<br>
(1)   Hardcopy of this document,
<br>
(1)   Hardcopy of the <i>Changes in 2.11BSD</i> document,
<br>
(1)   Hardcopy of the 2.11BSD /README and /VERSION files, and
<br>
(1)   Hardcopy of manual pages from sections 4, and 8.
<br>
</dl>
Installation on any machine requires a tape unit. 
Since certain standard PDP-11 packages
do not include a tape drive, this means one must either
borrow one from another PDP-11 system or one must be purchased
separately.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt><b>The distribution does not fit on several standard PDP-11 configurations
that contain only small disks</b>.  If your hardware configuration does not
provide at <b>least 75</b> Megabytes of disk space you can still install the
distribution, but you will probably have to operate without source for the
user level commands and, possibly, the source for the operating system.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>The root file system now occupies <b>a minimum of 4Mb</b>.  If at all possible
a larger, 6 or 7Mb, root partition should be defined when using the 
standalone
<b>disklabel
</b>program.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>If you have the facilities, it is a good idea to copy the
magnetic tape(s) in the distribution kit to guard against disaster.<tt> </tt>
The tapes are 9-track 1600 BPI, TK50 or TK25 cartridges and contain some
512-byte records, followed by some 1024-byte records,
followed by many 10240-byte records.<tt> </tt>
There are interspersed tape marks; end-of-tape is signaled
by a double end-of-file.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>The basic bootstrap material is present in six
short files at the beginning of the first tape.<tt> </tt>
The first file on the tape contains preliminary bootstrapping programs.<tt> </tt>
This is followed by several standalone
utilities (<i>disklabel</i>, <i>mkfs</i>(8), <i>restor</i>(8), and 
<i>icheck</i>(8)\(ua)
followed by a full dump of a root file system (see <i>dump</i>(8)).<tt> </tt>
Following the root file system dump is a tape archive image of <b>/usr</b>
except for <b>/usr/src</b> (see <i>tar</i>(1)).  Finally, a tape archive
of source for include files and kernel source ends the first tape.  The
second tape contains a tape archive image, also in <i>tar</i> format, of
all the remaining source that comes with the system.<tt> </tt>
</dl>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>The entire distribution (barely) fits on a single TK50 cartridge, references to
the second tape should be treated as being the 9th file on the TK50.  Many of
the programs in /usr/src/new have been tar+compress'd in order to keep the
distribution to a single tape.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt><br>TAPE 1:
<br>
Tape file   Record size   Records^   Contents
---------------------------------------------------------------------------------------
    0		 512	       1     primary tape boot block
		 512	       1     boot block (some tape boot ROMs go for this copy)
		 512	      69     standalone boot program
    1		1024	      37     standalone disklabel
    2		1024	      33     standalone mkfs(8)
    3		1024	      35     standalone restor(8)
    4		1024	      32     standalone icheck(8)
    5	       10240	     285     dump of ``root'' file system
    6	       10240	    3368     tar dump of /usr, excepting /usr/src
    7	       10240	     519     tar dump of /usr/src/include and /usr/src/sys

TAPE 2:
<pre>Tape file   Record size   Records^   Contents
-------------------------------------------------------------------------------------
    0	       10240	    4092     tar dump of /usr/src, excepting include and sys
</pre>
</dl>
<h2>3.&#160;<tt> </tt>UNIX device naming
</h2>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>UNIX has a set of names for devices which are different
from the DEC names for the devices.<tt> </tt>

The disk and tape names used by the bootstrap and the system are:
<dl><dt><dd>
RK06, RK07 disks		  hk
RL01, RL02 disks		  rl
RK05				  rk
MSCP disks			  ra
RM02/03/05			  xp
RP04/05/06			  xp
SMD disks			  xp
TM02/03, TE16, TU45, TU77 tapes   ht
TE10/TM11 tapes 		  tm
TS11 tapes			  ts
TMSCP tapes			  tms
</dl>
Additionally, the following non-DEC devices are also supported:
<dl><dt><dd>
SI 9500, CDC 9766		      si
SI, CDC 9775			      xp
SI6100, Fujitsu Eagle 2351A	      xp
Emulex SC01B or SI9400, Fujitsu 160   xp
Emulex SC-21, xp
</dl>
The generic SMD disk driver, <i>xp</i>, will handle
most types of SMD disks on one or more controllers
(even different types on the same controller).<tt> </tt>
The <b>xp</b> driver handles RM03, RM05, RP04, RP05 and  RP06
disks on DEC, Emulex, Dilog, and SI UNIBUS or MASSBUS controllers.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>MSCP disks and TMSCP tapes include SCSI drives attached to the 
RQZX1 controller on the PDP-11/93.  MSCP disks and TMSCP tapes also include
SCSI drives attached to the Emulex UC07 or UC08 Q-BUS controllers on Q-bus 
systems as well as the UC17 and UC18 controllers on UNIBUS systems.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>The standalone system used to bootstrap the full UNIX system
uses device names of the form:
<dl><dt><dd>
<i>xx</i>(<i>c</i>,<i>y</i>,<i>z</i>)
<br>
</dl>
where <i>xx</i> is one of <b>hk</b>, <b>ht</b>, <b>rk</b>, <b>rl</b>,
<b>tm</b>, <b>ts</b>, <b>tms</b>, or <b>xp</b>.<tt> </tt>
The value <i>c</i> specifies the controller number (0-3).  This value is
usually not explicitly given.  The default is 0 if booting from the standard
(first) CSR of a device.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>Example: if there are two MSCP controllers in
the system addressed as 0172150 and 0172154 respectively booting from the
controller at 172154 requires that <i>c</i> be given as 1.  Booting from
the standard CSR of 0172150 would be done by specifying <i>c</i> as 0 or
omitting the <i>c</i> parameter.<tt> </tt>
<b>boot</b> automatically detects if the 
first (standard) CSR is being used.   All future references will ignore
the <i>c</i> parameter by assuming the default value.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>The value <i>y</i>
specifies the device or drive unit to use.<tt> </tt>
The <i>z</i>
value is interpreted differently for tapes and disks:
for disks it is a partition number (0 thru 7) corresponding to partitions 
'a' thru 'h'
respectively.  This should always be zero unless you
<b>really</b> know what you are doing.  The ability to load a kernel from
the swap area is planned for the future but does not presently exist.<tt> </tt>
For tapes <i>z</i> is a file number on the tape.\(ua
</dl>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>In all simple cases, a drive with unit number 0 (determined either by
a unit plug on the front of the drive, or jumper settings on the drive
or controller) will be called unit 0 in its UNIX file name.<tt> </tt>
file name.<tt> </tt>
If there are multiple controllers, the drive unit numbers
will normally be counted within each controller.  Thus drives on
the the first controller are numbered 0 thru 7 and drives on the second
controller are numbered 0 thru 7 on controller 1.<tt> </tt>
Returning to the discussion of the standalone system, recall
that tapes also took two integer parameters.  In the case of a
TE16/TU tape formatter on drive 0, the
files on the tape have names ``ht(0,0)'', ``ht(0,1)'', etc.<tt> </tt>
Here ``file'' means a tape file containing a single data stream
separated by a single tape mark.<tt> </tt>
The distribution tapes have data structures in the tape
files and though the first tape contains only 7 tape files, it contains
several thousand UNIX files.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>Each UNIX physical disk is divided into 8 logical disk partitions,
each of which may occupy any consecutive cylinder range on the
physical device.  While overlapping partitions are allowed they are not
a good idea, being an accident waiting to happen (making one filesystem will
destroy the other overlapping filesystems).<tt> </tt>
The cylinders occupied
by the 8 partitions for each drive type
are specified
by the disk label read from the disk.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>If no label exists the disk will
not be bootable and while the kernel attempts not to damage
unlabeled disks (by swapping to or doing a crash dump on a live filesystem)
there is a chance
that filesystem damage will result if a kernel is loaded from an unlabeled 
disk.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>The standalone <b>disklabel</b> program is used to define the partition tables.<tt> </tt>
Each partition may be used
either as a raw data area (such as a swapping area) or to store a
UNIX file system.<tt> </tt>
It is mandatory for the first partition on a disk to start at sector offset 0
because the 'a' partition is used to read and write the label (which is at
the beginning of the disk).<tt> </tt>
If the drive is to be used 
to bootstrap a UNIX
system then the 'a' partition must be of type <b>2.11BSD</b> (FS_V71K in
<i>disklabel.h</i>) and at least 4Mb is size.  A 'b' partition of at least
2-3Mb (4Mb is a good choice if space is available) for swapping is 
also needed.<tt> </tt>
If a drive is being used solely for data then that drive need not
have a 'b' (swap) partition but partition 'a' must still span the first
part of the disk.<tt> </tt>
The second partition is used as a swapping area, and the
rest of the disk is divided into spaces for additional ``mounted
file systems'' by use of one or more additional partitions.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>The third ('c') logical partition of each physical disk also has a
conventional usage: it allows access to the entire physical device,
including the bad sector forwarding information recorded at the end of
the disk (one track plus 126 sectors).  It is occasionally used to store
a single large file system or to access the entire pack when making a
copy of it on another.  Care must be taken when using this partition not
to overwrite the last few tracks and thereby destroying the bad sector
information.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>Unfortunately while the drivers can follow the rules above the entries
in <i>/etc/disktab</i> (<i>disktab</i>(5)) do not.  The entries in 
<i>/etc/disktab</i> are translations of the old partition tables which
used to be embedded in the device drivers and are thus probably not suitable
for use without editing.<tt> </tt>
In some cases it
may be that the 8th ('h') partition is used for access to the entire
disk rather than the third ('c') partition.<tt> </tt>
Caution should be observed when using the <i>newfs</i>(8) and
<i>disklabel</i>(8) commands.<tt> </tt>
<h2>4.&#160;<tt> </tt>UNIX devices: block and raw
</h2>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>UNIX makes a distinction between ``block'' and ``raw'' (character)
devices.  Each disk has a block device interface where
the system makes the device byte addressable and you can write
a single byte in the middle of the disk.  The system will read
out the data from the disk sector, insert the byte you gave it
and put the modified data back.  The disks with the names
``/dev/xx0a'', etc are block devices.<tt> </tt>
There are also raw devices available.<tt> </tt>
These have names like ``/dev/rxx0a'', the
``r'' here standing for ``raw''.<tt> </tt>
Raw devices bypass the buffer cache and use DMA directly to/from
the program's I/O buffers;
they are normally restricted to full-sector transfers.<tt> </tt>
In the bootstrap procedures we
will often suggest using the raw devices, because these tend
to work faster.<tt> </tt>
Raw devices are used when making new filesystems,
when checking unmounted filesystems,
or for copying quiescent filesystems.<tt> </tt>
The block devices are used to mount file systems,
or when operating on a mounted filesystem such as the root.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>You should be aware that it is sometimes important whether to use
the character device (for efficiency) or not (because it wouldn't
work, e.g. to write a single byte in the middle of a sector).<tt> </tt>
Don't change the instructions by using the wrong type of device
indiscriminately.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>The standalone <b>disklabel</b> program must be used to alter the 'a' and 'b'
partitions of a drive being used for a bootable system.  This is because
the kernel will not permit an open partition to change size or offset.<tt> </tt>
The root and and swap partitions are <b>always</b> open when the kernel is
running.<tt> </tt>
<!--  Copyright (c) 1980 Regents of the University of California. -->
<!--  All rights reserved.  The Berkeley software License Agreement -->
<!--  specifies the terms and conditions for redistribution. -->
<!-- 	@(#)2.t	1.10 (GTE) 1997/8/11 -->
<br>
<br>
<b>
</b><b><center>2. BOOTSTRAP PROCEDURE
<br>
</center>
</b><b></b><p>
<p>
<b></b>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>This section explains the bootstrap procedure that can be used
to get the kernel supplied with this distribution running on your machine.<tt> </tt>
It is mandatory to do a full bootstrap since the filesystem has changed
from 2.10.1BSD to 2.11BSD.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>The safest route is to use <i>tar</i>(1) to dump all of your current
file systems, do a full bootstrap of 2.11BSD and then restore user files
from the backups.<tt> </tt>
There is also an untested version of <i>512restor</i>(8) available for
V7 sites that need to read old dump tapes.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>It is also desirable to make a convenient copy of system configuration
files for use as guides when setting up the new system; the list of files
to save from earlier PDP-11 UNIX systems, found in chapter 3, may be used
as a guideline.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>2.11BSD <i>restor</i>(8) is able to read and automatically convert to the
new on disk directory format
<i>dump</i>(8) tapes made under 2.9BSD, 2.10BSD and 2.10.1BSD.<tt> </tt>
<h2>4.1.&#160;<tt> </tt>Booting from tape
</h2>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>The tape bootstrap procedure used to create a
working system involves the following major
steps:
<dl>
<dt>1)<dd>
Load the tape bootstrap monitor.<tt> </tt>
<dt>2)<dd>
Create the partition tables on the disk using <i>disklabel</i>.<tt> </tt>
<dt>3)<dd>
Create a UNIX ``root'' file system system on disk using <i>mkfs</i>(8).<tt> </tt>
<dt>4)<dd>
Restore the full root file system using <i>restor</i>(8).<tt> </tt>
<dt>5)<dd>
Boot the UNIX system on the new root file system and copy the
appropriate <i>sector 0 boot block</i> to your boot device.<tt> </tt>
<dt>6)<dd>
Build and restore the /usr file system from tape
with <i>tar</i>(1).<tt> </tt>
<dt>7)<dd>
Restore the include and kernel sources from tape.<tt> </tt>
<dt>8)<dd>
Extract the remaining source from the second tape.<tt> </tt>
<dt>9)<dd>
Tailor a version of UNIX to your specific hardware (see section 4.2).<tt> </tt>
</dl>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>Certain of these steps are dependent on your hardware
configuration.  If your disks require formatting, standard DEC
diagnostic utilities will have to be used, they are not supplied on the
2.11BSD distribution tape.<tt> </tt>
<h2>4.1.1.&#160;<tt> </tt>Step 1: loading the tape bootstrap monitor
</h2>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>To load the tape bootstrap monitor, first
mount the magnetic tape on drive 0 at load point, making
sure that the write ring is not inserted.<tt> </tt>
Then use the normal bootstrap ROM, console monitor or other
bootstrap to boot from the tape.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>NOTE: The boot blocks expect the CSR of the booting controller in r0
and the unit number in r1.  <b>boot</b> may be booted from any controller
or unit, the earlier restrictions of controller 0 and unit 0 have been
lifted.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>If no other means are available, the following code can be keyed in
and executed at (say) 0100000 to boot from a TM tape drive (the magic number
172526 is the address of the TM-11 current memory address register;
an adjustment may be necessary if your controller is at a nonstandard
address):
<dl><dt><dd>
012700	 (mov $unit, r0)
000000	 (normally unit 0)
012701	 (mov $172526, r1)
172526
010141	 (mov r1, -(r1))
012741	 (mov $60003, -(r1))
060003	 (if unit 1 use 060403, etc)
000777	 (br .)
</dl>
A toggle-in routine which has been used with a TS tape drive (this should
be entered at 01000):
<dl><dt><dd>
012700	 mov $unit,r0
000000
012701	 mov $172522,r1
172522
005011	 clr (r1)
105711	 1b:tstb (r1)
100376	 bpl 1b
012761	 mov $setchr,-2(r1)
001040
177776
105711	 2b:tstb (r1)
100376	 bpl 2b
012761	 mov $read,-2(r1)
001060
177776
000000	 halt
140004	 setchr: TS_ACK|TS_CVC|TS_SETCHR
001050	 char
000000	 high order address
000010	 number of bytes
001070	 char: status
000000
000016
000000
140001	 read: TS_ACK|TS_CVC|TS_READ
000000	 low order of address
000000	 high order of address
001000	 number of bytes to read
000000	 status:
</dl>
When this is executed, the first block of the tape will be read into memory.<tt> </tt>
Halt the CPU and restart at location 0.  The register <b>r1</b> <b>MUST</b>
be left pointing at the device <i>csr</i>.  For the default/first TM or TS
this is 0172522.  The register <b>r0</b> <b>MUST</b> contain the unit number
(usually 0).<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>The console should type
<dl><dt><dd>
<b>
<br>
</b><i>nn</i><b>Boot from </b><i>xx</i><b>(</b><i>ctlr</i><b>,</b><i>drive</i><b>,</b><i>part</i><b>) at </b><i>csr</i><b>
<br>
:
<br>
</b>
<br>
</dl>
where <i>nn</i> is the CPU type on which it believes it is running.<tt> </tt>
The value will be one of 23, 24, 40, 44, 45, 53, 60, 70, 73, 83, 84, 93
or 94 depending whether
separate instruction and data (separate I/D) and/or a UNIBUS map are detected.<tt> </tt>
For KDJ-11 systems the System Maintenance Register is examined to determine
the cpu type.  At present 2.11BSD runs on the 44, 53, 70, 73, 83, 84, 93 and 94
<b>only</b>.  It must be emphasized that 2.11BSD requires separate I/D.<tt> </tt>
<p>
<i>ctlr</i> is the controller number that <b>Boot</b>
was loaded from.  It is 0 unless booting from a non-standard CSR.<tt> </tt>
<p>
<i>drive</i> is the drive unit number.<tt> </tt>
<p>
The <i>part</i>
number is disk partition or tapefile number booted from.  This will always
be 0 for the tape <b>Boot</b> program.<tt> </tt>
<p>
<i>csr</i> is an octal number telling the CSR of the controller from which
<b>Boot</b> was loaded.<tt> </tt>
<p>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>You are now talking to the tape bootstrap monitor.<tt> </tt>
At any point in the following procedure you can return
to this section, reload the tape bootstrap, and restart.<tt> </tt>
Through the rest of this section,
substitute the correct disk type for <i>dk</i>
and the tape type for <i>tp</i>.<tt> </tt>
<h2>4.1.2.&#160;<tt> </tt>Step 2: creating the disk label
</h2>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>The standalone <i>disklabel</i> program is then run:
<dl><dt><dd>
:tp(0,1)				       (disklabel is tape file 1)
Boot: bootdev=0nnnn bootcsr=0mmmmmm
disklabel
Disk? dk(0,0)				       (drive 0, partition 0)
d(isplay) D(efault) m(odify) w(rite) q(uit)?
 ...
:					       (back at tape boot level)
</dl>
The <i>disklabel</i> program is meant to be fairly intuitive.  When prompted
with a line of choices entering the key just before the left parenthesis
selects the entry.  
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>If there is an existing label present on <i>dk</i>(0,0) it will be 
used as the default.  To have <i>disklabel</i> create a new default based
on its idea of what the drive is select <b>D</b>.  Then enter <b>m</b> to
modify/edit the label.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>The MSCP driver is quite good at identifying drives because it can query the
controller.  Other drivers (notably the SMD (<b>xp</b>) driver) have to
deal with a much wider range of controllers which do not all have the
same capabilities for drive identification.  When dealing with SMD
drives you must know the geometry of the drive so you can verify  and
correct <i>disklabel</i>'s choices.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>You can however, if using non-DEC SMD controllers, make things easy for
<i>disklabel</i> to determine what type of drive is being used.  If your
controller offers the choice of RM02 emulation you should select that choice.<tt> </tt>
The standalone <b>xp</b> driver uses RM02 as the indication that drive 
identification capabilities
not offered by DEC controllers are present.  The driver will be able to
determine the geometry of the drive in this case.   This is <b>optional</b>
because you can explicitly specify all of the parameters to the standalone
<i>disklabel</i> program.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>A full description of the standalone <i>disklabel</i> program is in Appendix
B of this document.<tt> </tt>
<h2>4.1.3.&#160;<tt> </tt>Step 3: creating a UNIX ``root'' file system
</h2>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>Now create the root file system using the following procedure.\(ua
</dl>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>The size of the root ('a') filesystem was assigned in step 2 (creating the 
disk label).  <i>mkfs</i> will not allow a filesystem to be created if there
is not a label present or if the partition size is 0.  <i>mkfs</i> 
looks at partition 0 ('a') in the disklabel for the root file system size.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>Finally, determine the proper interleaving factors <i>m</i> and <i>n</i>
for your disk.  Extensive testing has demonstrated
that the choice of <i>m</i> is non critical (performance of a file system
varying only by 3 to 4% for a wide range of <i>m</i> values).  Values for
<i>m</i> within the range from  2 to 5 give almost identical performance.<tt> </tt>
Increasing <i>m</i> too much actually causes degraded performance because
the free blocks are too far apart.  Slower processors (such as the 73 and
44) may want to start with a <i>m</i> of 3 or 4, faster processors (such as the
70 and 84) may start with a <i>m</i> of 2 or 3.<tt> </tt>
On the other
hand, the <i>n</i> value is moderately important.  It should be the number
of filesystem blocks contained by one cylinder of the disk, calculated
by dividing the number of sectors per cylinder by 2, rounding down if
needed.  (This is what <i>mkfs</i> does by default, based on the
geometry information in the disk label.)
These numbers determine the layout of the free list that will be constructed;
the proper interleaving will help increase the speed of the file system.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>The number of bytes per inode determines how many inodes will be allocated
in the filesystem.  The default of 4096 bytes per inode is normally enough
(resulting in about 2000 inodes for a 8mb root filesystem and 1000 inodes
for the 4mb distribution ``generic'' root filesystem).  If more inodes are
desired then a lower value (perhaps 3072) should be specified when prompted
for the number of bytes per inode.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>Then run the standalone version of the <i>mkfs</i> (8) program.<tt> </tt>
The values in square brackets at the size prompt is the default from 
the disklabel.  Simply hit a return to accept the default.  <i>mkfs</i>
will allow you to create a smaller filesystem but you can not enter a
larger number than the one in brackets.<tt> </tt>
In the following procedure, substitute the correct types
for <i>tp</i> and <i>dk</i> and the size determined above for <i>size</i>:
<dl><dt><dd>
:tp(0,2)				   (mkfs is tape file 2)
Boot: bootdev=0nnnn bootcsr=0mmmmmm
Mkfs
file system: dk(0,0)			   (root is the first file system on drive 0)
file system size: [NNNN] size		   (count of 1024 byte blocks in root)
bytes per inode: [4096] bytes		   (number of bytes per inode)
interleaving factor (m, 2 default): m	   (interleaving, see above)
interleaving modulus (n, 127 default): n   (interleaving, see above)
isize = XX				   (count of inodes in root file system)
m/n = m n				   (interleave parameters)
Exit called
nnBoot
:					   (back at tape boot level)
</dl>
<p>
The number <b>nnnn</b> is the device number of the device (high byte is the
major device number and the low byte is the unit number).  The <b>mmmmmm</b>
number is the CSR of the device.  This information is mainly used as 
a reminder and diagnostic/testing purposes.<tt> </tt>
<p>
You now have an empty UNIX root file system.<tt> </tt>
<h2>4.1.4.&#160;<tt> </tt>Step 4: restoring the root file system
</h2>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>To restore the root file system onto it, type
<dl><dt><dd>
:tp(0,3)				 (restor is tape file 3)
Boot: bootdev=0nnnn bootcsr=0mmmmmm
Restor
Tape? tp(0,5)				 (root dump is tape file 5)
Disk? dk(0,0)				 (into root file system)
Last chance before scribbling on disk.	 (type a carriage return to start)
"End of tape"				 (appears on same line as message above)
Exit called
nnBoot
:					 (back at tape boot level)
<p>
This takes about 8 minutes with a TZ30 on a 11/93 and about 15 minutes using
a TK50 on a 11/73.<tt> </tt>
</dl>
If you wish, you may use the <i>icheck</i> program on the tape,
<i>tp</i>(0,4), to check the consistency of the file system you have just
installed.  This has rarely been useful and is mostly for the voyeuristic.<tt> </tt>
<h2>4.1.5.&#160;<tt> </tt>Step 5: booting UNIX
</h2>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>You are now ready to boot from disk.<tt> </tt>
Type:
<dl><dt><dd>
:dk(0,0)unix			      (bring in unix from the root system)
Boot: bootdev=0nnnn bootcsr=0mmmmmm
</dl>
The standalone boot program will then load unix from
the root file system you just created, and the system should boot:
<dl><dt><dd>
<b>
<br>
<!-- CHECK -->
2.11BSD BSD UNIX #1: Sat Jul 4 01:33:03 PDT 1992
<br>
    root@wlonex.iipo.gtegsc.com:/usr/src/sys/GENERIC
<br>
phys mem  = </b><i>???</i><b>
<br>
avail mem = </b><i>???</i><b>
<br>
user mem  = </b><i>???</i><b>
<br>

<br>
configure system
<br>
</b><i>... information about available devices ...</i><b>
<br>
</b>
<br>
(Information about various devices will print;
<br>
most of them will probably not be found until
<br>
the addresses are set below.)
<br>
<b>
<br>
erase=^?, kill=^U, intr=^C
<br>
#
<br>
</b>
<br>
</dl>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>UNIX itself then runs for the first time and begins by printing out a banner
identifying the release and
version of the system that is in use and the date that it was compiled.  
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>Next the
<i>mem
</i>messages give the amount of real (physical) memory, the amount of memory
left over after the system has allocated various data structures, and the
amount of memory available to user programs in bytes.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>The information about different devices being attached or not being found
is produced by the <i>autoconfig</i>(8) program.  Most of this is not
important for the moment, but later the device table, <i>/etc/dtab</i>,
can be edited to correspond to your hardware.  However, the tape drive of
the correct type should have been detected and attached.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>The ``erase ...'' message is part of /.profile
that was executed by the root shell when it started.  This message
is present to remind you that the character erase,
line erase, and interrupt characters are set to what is
standard for DEC systems; this insures that things are
consistent with the DEC console interface characters.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>UNIX is now running single user on the installed root file system,
and the `UNIX Programmer's Manual' applies.<tt> </tt>
The next section tells how to complete
the installation of distributed software on the /usr file system.<tt> </tt>
The `#' is the prompt from the shell,
and lets you know that you are the super-user,
whose login name is ``root''.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>The disk with the new root file system on it will not be bootable
directly until the block 0 bootstrap program for your disk has been installed.<tt> </tt>
There are copies of the bootstraps in /mdec.<tt> </tt>
Use <i>dd</i>(1) to copy the right boot block onto block 0 of the disk.<tt> </tt>
<dl><dt><dd>
<b>#</b> dd if=/mdec/<i>boot</i> of=/dev/r<i>dk</i>0a count=1
<br>
</dl>
Block zero bootstraps and the devices they support are:
<dl><dt><dd>
boot	    driver   devices
-------------------------------------------------------------------------
hkuboot     hk	     RK06/07
rauboot     ra	     All RA, RD, RZ, RX (except RX01,02) and RC25 drives
rkuboot     rk	     RK05
rluboot     rl	     RL01/02
si95uboot   si	     SI 9500, CDC 9766
dvhpuboot   xp	     Diva Comp V, Ampex 9300
hpuboot     xp	     RP04/05/06
rm03uboot   xp	     RM03
rm05uboot   xp	     RM05 or SI 9500, CDC 9766
si51uboot   xp	     SI 6100, Fujitsu Eagle 2351A
si94uboot   xp	     Emulex SC01B/SC03B or SI 9400, Fujitsu 160
</dl>
<b>NOTE:
</b>If none of the above are correct (most likely with a SMD drive with differing
geometry) then you will have to use a tape/floppy boot proceedure rather than
a sector 0 bootblock.  This can be fixed by creating a customized sector 0
boot program once the system sources have been loaded.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>Once this is done, booting from this disk will load and execute the block
0 bootstrap, which will in turn load /boot.  <b>/boot</b> will print
on the console:
<dl><dt><dd>
nnBoot from dk(ctlr,unit,part) at csr
:
</dl>
The bootblock automatically loads and runs /<i>boot</i> for you;
if /<i>boot</i> is not found, the system will hang/loop forever.<tt> </tt>
The block 0 program is very small (has to fit in 512 bytes) and simple 
program, however, and can only
boot the second-stage boot from the first file system.<tt> </tt>
Once /boot is running and prints its ``: '' prompt,
boot unix as above.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>As distributed /<i>boot</i> will load <i>dk</i>(0,0)unix by default if a
carriage return is typed at the <b>:</b> prompt.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt><b>NOTE:</b> NONE the primary bootstraps have a prompt or alternate program
name capability because of space considerations.  No diagnostic message
results if the file cannot be found.<tt> </tt>
<h2>4.1.6.&#160;<tt> </tt>Step 6: setting up the /usr file system
</h2>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>First set a shell variable to the name of your disk, so
the commands used later will work regardless of the disk you
have; do one of the following:
<dl><dt><dd>
# disk=hk   (if you have RK06's or RK07's)
# disk=rl   (if you have RL01's or RL02's)
# disk=ra   (if you have an MSCP drive)
# disk=xp   (if you have an RP06, RM03, RM05, or other SMD drive)
</dl>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>The next thing to do is to extract the rest of the data from the tape.<tt> </tt>
You might wish to review the disk configuration information in section
4.3 before continuing; you will have
to select a partition to restore the /usr file system into which is
at least <b>25</b> Megabytes in size (this is just barely enough for
the system binaries and such and leaves no room for the system
source.)\(ua
</dl>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>In the command below <i>part</i> is the partition name (a-h) for the partition
which will hold /usr.<tt> </tt>
<dl><dt><dd>
name=${disk}0${part}
</dl>
Next, find the tape you have in the following table and execute the
commands in the right hand portion of the table:
<dl><dt><dd>
DEC TM02/03, TE16/TU45/TU77   # cd /dev; rm *mt*; ./MAKEDEV ht0; sync
DEC TS11, TK25/TU80/TS05      # cd /dev; rm *mt*; ./MAKEDEV ts0; sync
DEC TM11, TU10/TE10/TS03      # cd /dev; rm *mt*; ./MAKEDEV tm0; sync
DEC TMSCP, TK50/TZ30/TU81     # cd /dev; rm *mt*; ./MAKEDEV tu0; sync
EMULEX TC11		      # cd /dev; rm *mt*; ./MAKEDEV tm0; sync
</dl>
Then execute the following commands:
<br>
<p>
<dl><dt><dd>
# date yymmddhhmm				 (set date, see date(1))
....
# passwd root					 (set password for super-user)
New password:					 (password will not echo)
Retype new password:
# hostname mysitename				 (set your hostname)
# newfs ${name} 				 (create empty user file system)
(this takes a minute)
# mount /dev/${name} /usr			 (mount the usr file system)
# cd /usr					 (make /usr the current directory)
# mt rew
# mt fsf 6
# tar xpbf 20 /dev/rmt12			 (extract all of usr except usr/src)
(this takes about 15-20 minutes except for the
TK50 and TZ30 which are much slower)
</dl>
The data on the seventh tape file has now been extracted.<tt> </tt>
All that remains on the first tape is a small archive containing
source for the kernel and include files.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>If you have an existing/old password file to be merged back into
2.11BSD, special steps are necessary to convert the old password file
to the shadow password file format (shadow password file 
and password aging were ported from 4.3BSD and are standard in 2.11BSD ).<tt> </tt>
<dl><dt><dd>
# mt -f /dev/rmt12 fsf			      (position tape at beginning of next tape file)
# mkdir src				      (make directory for source)
# cd src				      (make /usr/src the current directory)
# tar xpbf 20 /dev/rmt12		      (extract the system and include source)
(this takes about 5-10 minutes)
# cd /					      (back to root)
# chmod 755  /	/usr  /usr/src /usr/src/sys
# rm -f sys
# ln -s usr/src/sys sys 		      (make a symbolic link to the system source)
# umount /dev/${name}			      (unmount /usr)
</dl>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>The first tape has been been completely loaded.<tt> </tt>
You can check the consistency of the /usr file system by doing
<dl><dt><dd>
<b>#</b> fsck /dev/r${name}
<br>
</dl>
The output from
<i>fsck
</i>should look something like:
<dl><dt><dd>
<b>
<br>
** /dev/r</b><i>xx</i><b>0g
<br>
File System: /usr
<br>

<br>
NEED SCRATCH FILE (179 BLKS)
<br>
ENTER FILENAME:  /tmp/xxx
<br>
** Last Mounted on /usr
<br>
** Phase 1 - Check Blocks and Sizes
<br>
** Phase 2 - Check Pathnames
<br>
** Phase 3 - Check Connectivity
<br>
** Phase 4 - Check Reference Counts
<br>
** Phase 5 - Check Free List
<br>
671 files, 3497 used, 137067 free
<br>
</b>
<br>
</dl>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>If there are inconsistencies in the file system, you may be prompted
to apply corrective action; see the document describing
<i>fsck
</i>for information.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>To use the /usr file system, you should now remount it by
saying
<dl><dt><dd>
<b>#</b> mount /dev/${name} /usr
<br>
</dl>
<h2>4.1.7.&#160;<tt> </tt>Step 7: extracting remaining source from the second tape
</h2>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>You can then extract the source code for the commands from the
second distribution tape\(ua
(with the exception of RK07's, RM03's, and RD52's and other small disks
this will fit in the /usr file system):
<dl><dt><dd>
<b>#</b> cd /usr/src
<br>
<b>#</b> tar xpb 20
<br>
</dl>
If you get an error at this point, most likely it was
a problem with tape positioning.  Rewind the tape and
use the <b>mt</b> command to skip files, then retry the
<b>tar</b> command.<tt> </tt>
</dl>
<h2>4.2.&#160;<tt> </tt>Additional conversion information
</h2>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>After setting up the new 2.11BSD filesystems, you may restore the user
files that were saved on tape before beginning the conversion.  Note that
the 2.11BSD <i>restor</i> program does its work by accessing the raw file
system device and depositing inodes in the appropriate locations on
disk.  This means that file system dumps might not restore correctly if
the characteristics of the file system have changed (eg. if you're
restoring a dump of a file system into a file system smaller than the
original.)  To restore a dump tape for, say, the /u file system something
like the following would be used:
<dl><dt><dd>
<b>#</b> restor r /dev/rxp1e
<br>
</dl>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>If <i>tar</i> images were written instead of doing a dump, you should
be sure to use the `p' option when reading the files back.<tt> </tt>
No matter how you restore a file system, be sure and check its
integrity with <i>fsck</i> when the job is complete.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt><i>tar</i> tapes are preferred (when possible) because the inode
allocation is performed by the kernel rather than the <i>restor</i>(8)
program.  This has the benefit of allocating inodes sequentially starting
from the beginning of the inode portion of the filesystem rather than
preserving the fragmented/randomized order of the old filesystem.<tt> </tt>
<!--  Copyright (c) 1980 Regents of the University of California. -->
<!--  All rights reserved.  The Berkeley software License Agreement -->
<!--  specifies the terms and conditions for redistribution. -->
<!-- 	@(#)3.t	1.6 (2.11BSD GTE) 1996/11/16 -->
<p>
<br>
<b>
</b><b><center>3. UPGRADING AN EXISTING SYSTEM
<br>
</center>
</b><b></b><p>
<p>
<b></b>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>Begin by reading the document
``Changes to the System in 2.11BSD'' to get an idea of how
the system changes will affect your local modifications.<tt> </tt>
If you have local device drivers, see the file <i>/sys/OTHERS/README</i>
for hints on how to integrate your drivers into 2.11BSD.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>The only upgrade path to 2.11BSD is to do a full bootstrap as described
in Chapter 2.  As always, full backups of the existing system should
be made to guard against errors or failures.<tt> </tt>
<b>NOTE:</b> The old filesystems can not be mounted by the new
kernel.  If you must access old discs or filesystems, there is a
version of <i>dump</i>(8) in /usr/src/old/dump which can be used
with the <b>raw</b> disc to dump old filesystems.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>The archive file format has changed, the 4.3BSD <i>ar</i>(5) format is
now used.  Local archives will have to be converted by the <i>/usr/old/arcv</i>
program.<tt> </tt>
<h2>4.3.&#160;<tt> </tt>Files to save
</h2>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>The following list enumerates the standard set of files you will want to
save and suggests directories in which site specific files should be
present.  Note that because 2.10BSD changed so radically from previous
versions of UNIX on the PDP-11, many of these files may not exist on your
system, and will almost certainly require extensive changes for 2.11BSD,
but it's still handy to have them around as you're configuring 2.11BSD.<tt> </tt>
This list will likely be augmented with non-standard files you have added
to your system.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>You should create a <i>tar</i> image of
(at a minimum) the following files before the new file systems are created.<tt> </tt>
In addition, you should do a full dump before rebuilding the file system
to guard against missing something the first time around.  The 2.11BSD
<i>restor</i>(8) program can read and convert old <i>dump</i>(8) tapes.<tt> </tt>
<dl><dt><dd>
/.cshrc 	       ^   root csh startup script
/.login 	       ^   root csh login script
/.profile	       ^   root sh startup script
/.rhosts	       ^   for trusted machines and users
/dev/MAKEDEV	       =   in case you added anything here
/dev/MAKEDEV.local     *   for making local devices
/etc/disktab	       *   in case you changed disk partition sizes
/etc/dtab	       =   table of devices to attach at boot time
/etc/fstab	       ^   disk configuration data
/etc/ftpusers	       ^   for local additions
/etc/gateways	       ^   routing daemon database
/etc/gettytab	       ^   getty database
/etc/group	       ^   group data base
/etc/hosts	       ^   for local host information
/etc/hosts.dir	       *   must be rebuilt with mkhosts
/etc/hosts.pag	       *   must be rebuilt with mkhosts
/etc/hosts.equiv       ^   for local host equivalence information
/etc/networks	       ^   for local network information
/etc/netstart	       *   site dependent network startup script
/etc/passwd	       *   must be converted to shadow password file format
/etc/passwd.dir        *   must be rebuilt with mkpasswd
/etc/passwd.pag        *   must be rebuilt with mkpasswd
/etc/printcap	       ^   line printer database
/etc/protocols	       =   in case you added any local protocols
/etc/rc 	       *   for any local additions
/etc/rc.local	       *   site specific system startup commands
/etc/remote	       ^   auto-dialer configuration
/etc/services	       =   for local additions
/etc/syslog.conf       ^   system logger configuration
/etc/securettys        *   for restricted list of ttys where root can log in
/etc/ttys	       ^   terminal line configuration data
/etc/ttytype	       *   terminal line to terminal type mapping data
/etc/termcap	       =   for any local entries that may have been added
/lib		       =   for any locally developed language processors
/usr/dict/*	       =   for local additions to words and papers
/usr/hosts/MAKEHOSTS   ^   for local changes
/usr/include/*	       =   for local additions
/etc/aliases	       ^   mail forwarding data base
/etc/crontab	       ^   cron daemon data base
/usr/share/font/*      =   for locally developed font libraries
/usr/lib/lib*.a        ^   for local libraries
/usr/share/lint/*      =   for locally developed lint libraries
/etc/sendmail.cf       ^   sendmail configuration
/usr/share/tabset/*    =   for locally developed tab setting files
/usr/share/term/*      =   for locally developed nroff drive tables
/usr/share/tmac/*      =   for locally developed troff/nroff macros
/etc/uucp/*	       ^   for local uucp configuration files
/usr/man/manl	       *   for manual pages for locally developed programs
/usr/msgs	       ^   for current msgs
/usr/spool/*	       ^   for current mail, news, uucp files, etc.
/usr/src/local	       ^   for source for locally developed programs
/sys/conf/HOST	       ^   configuration file for your machine
/sys/conf/files.HOST   ^   list of special files in your kernel
/*/quotas	       *   file system quota files
<p>
\(uaFiles that can be used from 2.10BSD without change.<tt> </tt>
***Files that need local modifications merged into 2.11BSD files.<tt> </tt>
*Files that require special work to merge and are discussed below.<tt> </tt>
</dl>
<h2>4.3.1.&#160;<tt> </tt>Installing 2.11BSD
</h2>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>The next step is to build a working 2.11BSD system.<tt> </tt>
This can be done by following the steps in section 2 of
this document for extracting the root and /usr file systems
from the distribution tape onto unused disk partitions.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>Once you have extracted the 2.11BSD system and booted from it,
you will have to build a kernel customized for your configuration.<tt> </tt>
If you have any local device drivers,
they will have to be incorporated into the new kernel.<tt> </tt>
See section 4.2.3 and ``Building 2.11BSD UNIX Systems.''
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>With the introduction of disklabels the disk partitions in 2.11BSD the 
/etc/disktab file has changed dramatically.  There is a detailed description
later in this chapter about the changes.  If you have modified the 
partition tables in previous versions of 2.11BSD you will need to create
a new disktab entry or modify an existing one.<tt> </tt>
<h2>4.4.&#160;<tt> </tt>Merging your files from earlier PDP-11 UNIX systems into 2.11BSD
</h2>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>When your system is booting reliably and you have the 2.11BSD
root and /usr file systems fully installed you will be ready
to continue with the next step in the conversion process,
merging your old files into the new system.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>If you saved the files on a <i>tar</i> tape, extract them
into a scratch directory, say /usr/convert:
<dl><dt><dd>
<b>#</b> mkdir /usr/convert
<br>
<b>#</b> cd /usr/convert
<br>
<b>#</b> tar x
<br>
</dl>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>For sites running 2.10.1BSD, converting local configuration files should be
very simple.  In general very little has changed between 2.10.1BSD and 2.11BSD
with regard to these files.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>For sites running a pre-2.10BSD UNIX, there is very little that can be
said here as the variety of previous versions of PDP-11 UNIX systems and how
they were administered is large.  As an example, most previous versions
of PDP-11 UNIX systems used the files <i>/etc/ttys</i> and <i>/etc/ttytype</i>
to administer which terminals should have login processes attached to
them and what the types of terminals those were.  Under 2.11BSD
/etc/ttytype has disappeared entirely, its functions subsumed by
/etc/ttys along with several new functions.  In general you will simply
have to use your previous configuration files as references as you
configure 2.11BSD to your site needs.  Familiarity with 4.3BSD
configuration is very helpful at this point since
2.11BSD is nearly identical in most of the files listed in the previous
section.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>If you have any home grown device drivers
that use major device numbers reserved by the system you
will have to modify the commands used to create the devices or alter
the system device configuration tables in /sys/pdp/conf.c.<tt> </tt>
Note that almost all 2.11BSD major device numbers are different from
those in previous PDP-11 UNIX systems except 2.10.1BSD.  A couple more device
numbers were added since the release of 2.10.1BSD for the kernel logging
facility (/dev/klog) and a (new) TK50/TU81 driver.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>System security changes require adding several new ``well-known'' groups 
to /etc/group.<tt> </tt>
The groups that are needed by the system as distributed are:
<dl><dt><dd>
name	   number
------------------
wheel	     0
daemon	     1
kmem	     2
sys	     3
tty	     4
operator     5
staff	     10
bin	     20
</dl>
Only users in the ``wheel'' group are permitted to <i>su</i> to ``root''.<tt> </tt>
Most programs that manage directories in /usr/spool
now run set-group-id to ``daemon'' so that users cannot
directly access the files in the spool directories.<tt> </tt>
The special files that access kernel memory, <i>/dev/kmem</i>
and <i>/dev/mem</i>, are made readable only by group ``kmem''.<tt> </tt>
Standard system programs that require this access are
made set-group-id to that group.<tt> </tt>
The group ``sys'' is intended to control access to system sources,
and other sources belong to group ``staff.''
Rather than make user's terminals writable by all users,
they are now placed in group ``tty'' and made only group writable.<tt> </tt>
Programs that should legitimately have access to write on user's terminals
such as <i>talk</i> and <i>write</i> now run set-group-id to ``tty''.<tt> </tt>
The ``operator'' group controls access to disks.<tt> </tt>
By default, disks are readable by group ``operator'',
so that programs such as <i>df</i> can access the file system
information without being set-user-id to ``root''.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>Several new users have also been added to the group of ``well-known'' users 
in /etc/passwd.<tt> </tt>
The current list is:
<dl><dt><dd>
name	   number
------------------
root	     0
daemon	     1
operator     2
uucp	     66
nobody	   32767
</dl>
The ``daemon'' user is used for daemon processes that
do not need root privileges.<tt> </tt>
The ``operator'' user-id is used as an account for dumpers
so that they can log in without having the root password.<tt> </tt>
By placing them in the ``operator'' group, 
they can get read access to the disks.<tt> </tt>
The ``uucp'' login has existed long before 2.11BSD,
and is noted here just to provide a common user-id.<tt> </tt>
The password entry ``nobody'' has been added to specify
the user with least privilege.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>After restoring your old password file from tape/backups, a conversion is
required to create the shadow password file.  Only the steps
to convert /etc/passwd are given here, see the various man pages
for <i>chpass</i>(1), <i>vipw</i>(8), <i>mkpasswd</i>(8), etc.<tt> </tt>
<dl><dt><dd>
<b>#</b> awk -f /etc/awk.script &lt; /etc/passwd &gt;/etc/junk
<br>
<b>#</b> mkpasswd -p /etc/junk
<br>
<b>#</b> mv /etc/junk.orig /etc/passwd
<br>
<b>#</b> mv /etc/junk.pag /etc/passwd.pag
<br>
<b>#</b> mv /etc/junk.dir /etc/passwd.dir
<br>
<b>#</b> mv /etc/junk /etc/master.passwd
<br>
<b>#</b> chown root /etc/passwd* /etc/master.passwd
<br>
<b>#</b> chmod 0600 /etc/master.passwd
<br>
</dl>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>The format of the cron table, /etc/crontab, is the same as that
of 2.10.1BSD.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>Some of the commands previously in /etc/rc.local have been 
moved to /etc/rc;
several new functions are now handled by /etc/rc.local.<tt> </tt>
You should look closely at the prototype version of /etc/rc.local
and read the manual pages for the commands contained in it
before trying to merge your local copy.<tt> </tt>
Note in particular that <i>ifconfig</i> has had many changes,
and that host names are now fully specified as domain-style names
(e.g, boris.Oswego.EDU).<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>The C library and system binaries on the distribution tape
are compiled with versions of
<i>gethostbyname</i> and <i>gethostbyaddr</i> which use
ndbm host table lookup routines instead of the name server.<tt> </tt>
You must run <i>mkhosts</i>(8) to create the <i>ndbm</i>
host table database from <i>/etc/hosts</i>.  For 2.11BSD the <i>mkhosts</i>
program has been enhanced to support multiple addresses per host with
order being preserved (the order in which the multiple
addresses appear in <i>/etc/hosts</i> for the same host is the same order
the addresses will be returned to the caller of <i>gethostbyname</i>).<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>There is a version of the nameserver which runs under 2.11BSD.  However
in addition to having a voracious appetite for memory there are memory
leaks which cause <i>named</i>(8) to crash after running for an
extended period.  Restarting <i>named</i>(8) nightly from <i>cron</i>
is the only work around solution at present.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>If you want to compile your system to use the
name server resolver routines instead of the ndbm host table, you will
need to modify /usr/src/lib/libc/Makefile according to the instructions there
and then recompile all of the system and local programs (see section 6.5).\(ua
</dl>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>The format of /etc/ttys is the same as it was under 2.10BSD.<tt> </tt>
It includes the terminal type and security options that were previously
in /etc/ttytype and /etc/securettys.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt><i>syslog</i> is the 4.4BSD-Lite version now.<tt> </tt>
See <i>syslog</i>(3) and <i>syslogd</i>(8) for details.<tt> </tt>
They are used by many of the system daemons
to monitor system problems more closely, for example
network routing changes.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>Again, it must be emphasized that the nameserver is not robust under
2.11BSD, and if the <i>hosts</i> files are not desired then the best
alternative is to use the <i>resolver</i>(5) routines and use
the nameserver on a remote larger machine.  The <i>resolver</i>(5)
routines are known to work.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>The spooling directories saved on tape may be restored in their
eventual resting places without too much concern.  Be sure to
use the ``p'' option to <i>tar</i> so that files are recreated with the
same file modes:
<dl><dt><dd>
<b>#</b> cd /usr
<br>
<b>#</b> tar xp msgs spool/mail spool/uucp spool/uucppublic spool/news
<br>
</dl>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>The ownership and modes of two of these directories
needs to be changed, because
<i>at</i> now runs set-user-id ``daemon'' instead of root.<tt> </tt>
Also, the uucp directory no longer needs to be publicly writable,
as <i>tip</i> reverts to privileged status to remove its lock files.<tt> </tt>
After copying your version of /usr/spool, you should do the following:
<dl><dt><dd>
<b>#</b> chown -R daemon /usr/spool/at
<br>
<b>#</b> chown -R root /usr/spool/uucp
<br>
<b>#</b> chgrp -R daemon /usr/spool/uucp
<br>
<b>#</b> chmod -R o-w /usr/spool/uucp
<br>
</dl>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>Whatever else is left is likely to be site specific or require
careful scrutiny before placing in its eventual resting place.<tt> </tt>
Refer to the documentation and source code 
before arbitrarily overwriting a file.<tt> </tt>
<h2>4.5.&#160;<tt> </tt>Hints on converting from previous PDP-11 UNIX systems to 2.11BSD
</h2>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>This section summarizes some of the significant changes in 2.11BSD
from 2.10.1BSD.  The installation guide for 2.10.1BSD is included in the
distribution as /usr/doc/2.10/setup.2.10 and should be read if
you are not presently running 2.10BSD or 2.10.1BSD.<tt> </tt>
It does not include changes in the network;
see chapter 5 for information on setting up the network.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>Old core files will not be intelligible by the current debuggers
because of numerous changes to the user structure.<tt> </tt>
Also removed from the user structure are the members u_offset, u_count,
u_base, u_segflg, the 4.3BSD uio/iovec/rdwri kernel i/o model having
been put in place.  The 4.3BSD <i>namei</i> argument encapsulation 
technique has been ported, which adds the u_nd member to the user
structure.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>Note, once your system is installed and running, you
should make sure that you recompile and reinstall the directory
<i>/usr/src/share/zoneinfo</i>.  Read through the Makefile first, if you're
not located on the West Coast you will have to change it.  This directory
is an addition since 4.3BSD, and is intended to solve the Daylight
Savings Time problems once and for all.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>The incore inode structure has had the i_id member added as part
of implementing the 4.3BSD namei cache.  The di_addr member of the
on disk inode structure is now an array of type <b>daddr_t</b> instead 
of <b>char</b>.  The old 3 byte packed block number is obsolete at last.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>The on disk directory structure is that of 4.3BSD with the difference
that the inode number is an unsigned short instead of a long.  This was
done to reduce the amount of long arithmetic in the kernel and to maintain
compatibility with earlier versions with regard to the maximum number of
inodes per filesystem.  Given the typical size of discs used with 2.11BSD
the limit on the number of inodes per filesystem will not be a problem.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>And again, 2.11BSD is not filesystem compatible with any previous PDP-11 UNIX system.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>If you want to use <i>ps</i> after booting a new kernel,
and before going multiuser, you must initialize its name list
database by running <i>ps -U</i>.<tt> </tt>
<h2>4.6.&#160;<tt> </tt>Hints on possible problems upgrading from the 2.10.1BSD
</h2>
<h2>4.6.1.&#160;<tt> </tt>New utmp UT_NAMESIZE.<tt> </tt>
</h2>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt><b>UT_NAMESIZE
</b>in
<i>&lt;</i>utmp.h
was changed from 8 to 15.  This won't affect correctly written programs
(those which do not hard code the constant 8) at the source
level but does cause changes in various databases.  This means that old
binaries won't be able to cope with new databases (passwd, aliases, etc)
and vice versa.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>This change was necessary since the systems available for 2.11BSD development
had to be shared with systems in which UT_NAMESIZE was set at 15.  If this
change/incompatibility is not desired, then utmp.h and wtmp.h will have to
be modified and the system libraries and applications rebuilt before 
proceeding to load local software.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>The simplest way to deal with this incompatibility is simply to rebuild
all your databases from the source data.  In particular, you should be sure
you rebuild
<i>/etc/passwd</i>,
<i>/etc/hosts</i>,
and
<i>/etc/aliases
</i>databases via the commands:
<i>mkpasswd /etc/passwd</i>,
<i>mkhosts /etc/hosts</i>,
and
<i>/usr/ucb/newaliases.</i>
<h2>4.6.2.&#160;<tt> </tt>man system
</h2>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>The manual system continues to track the changes
going on in 4BSD.  I'm not convinced the new setup is better, but it does
seem to be the method of the moment.<tt> </tt>
The setup is essentially the same as that in the
<b>4.3BSD-TAHOE
</b>distribution with the manual source in /usr/src/man.<tt> </tt>
<h2>4.6.3.&#160;<tt> </tt>NMOUNT lowered
</h2>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>The value of
<b>NMOUNT
</b>in
<i>/sys/h/param.h
</i>is set to 5 in the distribution system.  This will be
too small for many sites.  Since each mount table entry costs about
440 bytes of valuable kernel dataspace this number should be chosen
with care.  See Appendix A for an explanation of how to
reconfigure
<b>NMOUNT.
</b><h2>4.6.4.&#160;<tt> </tt>Shadow passwords
</h2>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>The May 1989 release of the 4.3BSD shadow password file has been ported
to 2.11BSD.  Password aging is also implemented.<tt> </tt>
<h2>4.6.5.&#160;<tt> </tt>New /etc/rc startup scripts
</h2>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt><i>/etc/rc
</i>and
<i>/etc/rc.local
</i>have changed fairly significantly, and
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt><i>/etc/netstart
</i>has been added to configure site specific network features (much of this
was pulled from the old rc.local).<tt> </tt>
<i>/etc/netstart
</i>uses the tiny program <i>testnet</i> which attempts to create a socket and
prints NO on stdout if an error is returned by the kernel, YES
if no error was returned.<tt> </tt>
<h2>4.6.6.&#160;<tt> </tt>mkfs, mkproto, mklost+found
</h2>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt><i>mkfs</i>(8) no longer can populate a filesystem with files.  The
4.3BSD versions of <i>mkfs</i>(8) and <i>mkproto</i>(8) were ported
to 2.11BSD.  There is a limit on the size of the file which <i>mkproto</i>(8)
can place on a newly created filesystem.  Only files up to single indirect
(about 260kb) may be copied at this time.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt><i>mklost+found</i>(8) is a ported version from 4.3BSD, the only change being to
use 63 character file names (MAXNAMLEN is 63 at this time in 2.11BSD) instead
of 255.   <i>mklost+found</i>(8) is really not needed, <i>fsck</i>(8) is
now capable of automatically extending lost+found by up to the number
of direct blocks in an inode.<tt> </tt>
<h2>4.6.7.&#160;<tt> </tt>/etc/disktab
</h2>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>The format of /etc/disktab
is now the same as 4.3BSD-Reno and 4.4BSD.  Previously to describe a drive
(an RM03 for example) the /etc/disktab
file had entries of the form:
<p>
:ty=removable:ns#32:nt#5:nc#823:sf:
<br>
:b0=/mdec/rm03uboot:
<br>
:pa#9600:ba#1024:fa#1024:
<br>
:pb#9600:bb#1024:fb#1024:
<br>
:pc#131520:bc#1024:fc#1024:
<br>
:pf#121920:bf#1024:ff#1024:
<br>
:pg#112320:bg#1024:fg#1024:
<br>
:ph#131520:bh#1024:fh#1024:
<br>
<p>
Note that there is no information at all about which cylinder a partition
starts at or which partitions overlap and may not be used simultaneously.<tt> </tt>
That information was kept in tables in the driver.  If you modified 
/etc/disktab it would have no effect without also changing the driver and
recompiling the kernel.<tt> </tt>
<p>
The new /etc/disktab file looks like this:
<p>
:ty=removable:ns#32:nt#5:nc#823:sf:
<br>
:b0=/mdec/rm03uboot:
<br>
:pa#9600:oa#0:ba#1024:fa#1024:ta=2.11BSD:
<br>
:pb#9600:ob#9600:bb#1024:fb#1024:tb=swap:
<br>
:pc#131520:oc#0:bc#1024:fc#1024:
<br>
:pf#121920:of#9600:bf#1024:ff#1024:tf=2.11BSD:
<br>
:pg#112320:og#19200:bg#1024:fg#1024:tg=2.11BSD:
<br>
:ph#131520:oh#0:bh#1024:fh#1024:th=2.11BSD
<br>
<p>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>There are two new fields per partition, the 'o' (oa, ob, usw.) field
specifies the offset in sectors that the partition begins at.  The 't'
field specifies the partition type.  Only those partitions which are
<b>2.11BSD</b> will be recognized by <i>newfs</i>(8) and the kernel as 
filesystems.<tt> </tt>
The kernel also will not swap or place a crash dump on a partition that
is not of type <b>swap</b>.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>The two examples above are equivalent and provide an example of a 
translating an old style disktab entry into a new style entry.  To translate
a customized disktab entries you will need:  1) a copy of your
current partition tables from the device driver, 2) a copy of the 
old disktab entry, 3) your current /etc/fstab file.  In new disktab entries
you should only place those partitions you actually use.  There is no
need to declare (as was done in the examples above) all of the possible
partitions.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>If you
have changed the disk partition sizes, be sure to make the necessary
/etc/disktab changes and label your disks
BEFORE trying to access any of
your old file systems!<tt> </tt>
There are two ways to label your disks.  The standalone disklabel program 
is one way.  It is also possible to label disks using <i>disklabel</i>(8) 
with the -r option - this works even when running on a kernel which does
not support labels (-r reads and writes the raw disk, thus it is possible
to label disks on an older kernel as long as the <i>disklabel</i>(8) 
program is present).<tt> </tt>
<!--  Copyright (c) 1980 Regents of the University of California. -->
<!--  All rights reserved.  The Berkeley software License Agreement -->
<!--  specifies the terms and conditions for redistribution. -->
<!-- 	@(#)4.t	2.3 (2.11BSD GTE) 1996/11/27 -->
<br>
<b>
</b><b><center>4. SYSTEM SETUP
<br>
</center>
</b><b></b><p>
<p>
<b></b>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>This section describes procedures used to set up a PDP-11 UNIX system.<tt> </tt>
These procedures are used when a system is first installed
or when the system configuration changes.  Procedures for normal
system operation are described in the next section.<tt> </tt>
<h2>4.7.&#160;<tt> </tt>Creating a UNIX boot
</h2>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt><i>/boot</i> uses the device information passed to it from the bootstrap
in determining the device, unit and file to load.   If an autoreboot
is being done the kernel will have passed the device information to the 
bootstrap as well as setting the autoreboot flag.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt><i>/boot</i> does not require recompilation to adapt to a new autoreboot
device.<tt> </tt>
<h2>4.8.&#160;<tt> </tt>Kernel configuration
</h2>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>This section briefly describes the layout of the kernel code and
how files for devices are made.<tt> </tt>
<h2>4.8.1.&#160;<tt> </tt>Kernel organization
</h2>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>As distributed, the kernel source is in a 
separate tar image.  The source may be physically
located anywhere within any file system so long as
a symbolic link to the location is created for the
file /sys
(many files in /usr/include are normally symbolic links
relative to /sys).  In further discussions of the
system source all path names will be given relative to
/sys.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>The directory /sys/sys
contains the mainline machine independent
operating system code.<tt> </tt>
Files within this directory are conventionally
named with the following prefixes:
<dl><dt><dd>
init_	     system initialization
kern_	     kernel (authentication, process management, etc.)
quota_	     kernel portion of disk quota system
subr_	     misc. subroutines used throughout the kernel
sys_	     system calls and the like
tty_	     terminal handling
ufs_	     file system
uipc_	     interprocess communication
vm_	     memory management
</dl>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>The remaining directories are organized as follows:
<dl><dt><dd>
/sys/h	       machine independent include files
/sys/conf      site configuration files and basic templates
/sys/net       network independent, but network related code
/sys/netinet   DARPA Internet code
/sys/netimp    IMP support code
/sys/netns     Xerox NS support code
/sys/pdp       PDP-11 specific mainline code
/sys/pdpif     PDP-11 network interface code
/sys/pdpmba    PDP-11 MASSBUS device drivers and related code
/sys/pdpuba    PDP-11 UNIBUS device drivers and related code
</dl>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>Many of these directories are referenced through /usr/include with
symbolic links.  For example, /usr/include/sys is a symbolic
link to /sys/h.  The system code, as distributed, is mostly
independent of the include files in /usr/include.  Unfortunately
not all references to /usr/include have been eradicated, so
compiling the system requires the /usr file system to be mounted.<tt> </tt>
<h2>4.8.2.&#160;<tt> </tt>Devices and device drivers
</h2>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>Devices supported by UNIX are implemented in the kernel
by drivers whose source is kept in /sys/pdp, /sys/pdpuba,
or /sys/pdpmba.  These drivers are loaded
into the system when included in a cpu specific configuration file
kept in the conf directory.  Devices are accessed through special
files in the file system, made by the
<i>mknod</i>(8)
program and normally kept in the /dev directory.<tt> </tt>
For all the devices supported by the distribution system, the
files in /dev are created by the /dev/MAKEDEV
shell script.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>Determine the set of devices that you have and create a new /dev
directory by running the MAKEDEV script.<tt> </tt>
First create a new directory
/newdev, copy MAKEDEV into it, edit the file MAKEDEV.local
to provide an entry for local needs,
and run it to generate a /newdev directory.<tt> </tt>
For instance, if your machine has a single DZ11, a single
DH11, an RM03 disk, an EMULEX UNIBUS SMD disk controller, an
AMPEX 9300 disk, and a TE16 tape drive you would do:
<dl><dt><dd>
<b>#</b> cd /
<br>
<b>#</b> mkdir newdev
<br>
<b>#</b> cp dev/MAKEDEV newdev/MAKEDEV
<br>
<b>#</b> cd newdev
<br>
<b>#</b> MAKEDEV dz0 dh0 xp0 xp1 ht0 std LOCAL
<br>
</dl>
Note the ``std'' argument causes standard devices
such as <i>/dev/console</i>, the machine console, <i>/dev/null</i>,
<i>/dev/tty</i>, <i>/dev/klog</i>, etc.<tt> </tt>
to be created.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>You can then do
<dl><dt><dd>
<b>#</b> cd /
<br>
<b>#</b> mv dev olddev ; mv newdev dev
<br>
<b>#</b> sync
<br>
</dl>
to install the new device directory.\(ua
As distributed almost all of
the device nodes are already present and you may wish to remove
unused entries from /dev to speed up scanning of the directory.<tt> </tt>
The terminal nodes are almost certainly incorrect for your site and
will need to be deleted and recreated.  Directly connected terminals
should have the softcarrier bit on in their minor device numbers.  Since
MAKEDEV by default creates terminal (dh, dz, etc) nodes with the softcarrier
bit off you will have to delete those nodes and recreate those terminal
nodes which are directly connected:
<dl><dt><dd>
<b>#</b> cd /dev
<br>
<b>#</b> rm ttyh0
<br>
<b>#</b> mknod ttyh0 c 3 128
<br>
</dl>
</dl>
<h2>4.8.3.&#160;<tt> </tt>Building new system images
</h2>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>The kernel configuration of each UNIX system is described by
a single configuration file, stored in the <i>/sys/conf</i> directory.<tt> </tt>
The format of this file is very simple consisting of lines starting with
an <i>identifier</i> followed by a <i>value</i>.  Blank lines and anything
past a ``#'' (including the #) are comments.  This file is processed by the
shell script <i>config</i> in the same directory.<tt> </tt>
The manual pages in section 4 of the UNIX manual specify the configuration
lines necessary for various devices.  A comprehensive list of system
options with descriptions of their meanings and effects can be found in
appendix A.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>The configuration file <i>GENERIC</i> in the conf directory was used to
build the generic distribution kernel.  To build a local configuration
file, copy GENERIC to a new file <i>SYSTEM</i>, edit <i>SYSTEM</i> for your
local system configuration, and then type "./config <i>SYSTEM</i>".  This
will create the directory <i>../SYSTEM</i> and copy specially edited files
into based on the definitions in <i>SYSTEM</i>.  Change directory into the
new system directory and type "make all".\(ua,
<dl><dt><dd>
<b>#</b> cp GENERIC <i>SYSTEM</i>
<br>
<b>#</b> TERM=<i>terminal_type</i>; export TERM
<br>
<b>#</b> vi <i>SYSTEM</i>
<br>
<b>#</b> ./config <i>SYSTEM</i>
<br>
<b>#</b> cd ../<i>SYSTEM</i>
<br>
<b>#</b> make
<br>
</dl>
</dl>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>Note that the overlay scheme in the Makefile copied into the new system
directory may fail because either the <i>base segment</i> is too small, too
large or one or more <i>overlay segments</i> are too large.  If this
happens the system objects will have to be re-arranged in the <i>base</i>
and <i>overlay</i> segments.  The comments in the Makefile should make it
fairly clear what the restrictions on object placement are in the system.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>The configured system image ``unix''***
should be
copied to the root, and then booted to try it out.<tt> </tt>
It is best to save the old kernel to a known name so as not to destroy
the working system until you're sure the new one does work.  It is an
<b>better</b> idea to have a non network kernel (/emergencyunix) always
kept on the system:
<dl><dt><dd>
<b>#</b> cp /unix /oldunix
<br>
<b>#</b> make install
<br>
<b>#</b> sync
<br>
</dl>
To boot the new version of the system you should follow the
bootstrap procedures outlined in section titled ``<b>Bootstrap and
shutdown procedures</b>''
A systematic scheme for numbering and saving old versions
of the system may be useful.<tt> </tt>
</dl>
<h2>4.9.&#160;<tt> </tt>Disk configuration
</h2>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>This section describes how to layout file systems to make use
of the available space and to balance disk load for better system
performance.<tt> </tt>
<h2>4.9.1.&#160;<tt> </tt>Disk naming and divisions
</h2>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>Each physical disk drive can be divided into up to 8 partitions;
UNIX typically
uses only 3 or 4 partitions.<tt> </tt>
For instance, on an RP06
the first partition, xp0a,
is used for a root file system, a backup thereof,
or a small file system like, /tmp;
the second partition, xp0b,
is used for swapping or a small file system; and
a combination of the remaining partitions (xp0d, xp0e, xp0f, xp0g, xp0h)
would hold user file systems.<tt> </tt>
<p>
<dl><dt><dd>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt><b>Warning:</b>  for disks on which DEC standard 144 bad sector forwarding
is supported, the last track and up to 126 preceding sectors
contain replacement sectors and bad sector lists.<tt> </tt>
Disk-to-disk copies should be careful to avoid overwriting this information.<tt> </tt>
See <i>bad144</i>(8).<tt> </tt>
Bad sector forwarding is optional in the <b>hk</b>
and <b>xp</b> drivers.<tt> </tt>
The partition sizes listed in <i>/etc/disktab</i> that <i>newfs</i>(8)
uses automatically reserve the maximum amount of room that may be used
by bad block forwarding on a disk.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>Note also that bad144 style bad block forwarding <i>can not</i> be used
with SI controllers on the xp driver as the controllers use their own
internal scheme for bad block forwarding, and you can in fact make your
disks unusable on the SI controllers if you write anything in the last
five cylinders.  The partition sizes in <i>/etc/disktab</i> also handle
this constraint automatically.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>The generic distribution kernel does not do bad block forwarding.  There is
unfortunately no way to run bad144 style bad block forwarding on some of your
disks, but not others.  As a final bug, the hk and xp drivers do not reread
the bad sector forwarding information when disk packs are changed and so
will erroneously use bad block forwarding information from the wrong packs!<tt> </tt>
</dl>
<p>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>The space available on a disk varies, not surprisingly, per device.  
Disklabels make a table giving sizes meaningless since there are no
predefined partition sizes embedded in the kernel any longer.  The root
filesystem (<b>a</b>) must be at least 4Mb, preferably 6 to 7Mb if possible.<tt> </tt>
The swap area (almost always the <b>b</b> partition) should be about 3Mb or
so.  If your system has a small amount (less than 2Mb) of memory you will
need more swap space, perhaps 4 or 5Mb.  It is a rare case where more than
5 or 6Mb of swap space is required.   The system will run out of other
resources by the time enough activity is generated to need that much swap
space.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>The system (boot) disk has a swapping area and
a root file system.  Other drives may use those partitions for data.<tt> </tt>
<b>Remember:</b> the <b>a</b> partition must start at sector 0 or
<i>disklabel</i>(8) or else the kernel will not be able to read/write the
label.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>The distributed system binaries occupy about 34 Megabytes
while the major sources occupy another 36 Megabytes.  Adding in the
miscellaneous sources, a few locate works of art bring the total for
a complete system to about 90 Megabytes.<tt> </tt>
This overflows RK07, RL02 and RM03 systems,
but fits easily on most other hardware configurations.  2.11BSD is quite
happy on RD54 or larger.  Simply fitting the distribution isn't enough,
there must still be space left for user files, objects when compiling
programs, spooling directories, usw.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>Be aware that the disks have their sizes measured in disk sectors (512
bytes), while the UNIX file system blocks are 1024 bytes each.  Thus if a
disk partition has 10000 sectors (disk blocks), it will have only 5000
UNIX file system blocks, and you <i>must</i> divide by 2 to use 5000 when
specifying the size to the <i>mkfs</i> command for instance.  The 
<i>newfs</i>(8) program performs this calculation automatically.   You
should <b>never</b> need to run <i>mkfs</i> manually.<tt> </tt>
All user
programs report disk space in kilobytes and, where needed, disk sizes are
always specified in units of sectors.  The /etc/disktab file used in
making file systems specifies disk partition sizes in sectors; the
default sector size may be overridden with the ``se'' attribute.  <b>Note</b>
that the only sector size currently supported is NBPG as defined in 
<i>/sys/pdp/machparam.h</i>.  This restriction is enforced in several places
in the disklabeling process as a safeguard against specifying a sector
size other than NBPG (512).  Any other sector size would produce strange
results and almost certainly curdled filesystems.<tt> </tt>
<h2>4.9.2.&#160;<tt> </tt>Layout considerations
</h2>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>There are several considerations in deciding how
to adjust the arrangement of things on your disks.<tt> </tt>
The most important is making sure that there is adequate space
for what is required; secondarily, throughput should be maximized.<tt> </tt>
Swap space is an important parameter since it defines the maximum
process image load that may be run.  If, for instance, your swap
area were smaller than the amount of main memory available after
the kernel took its share, some of your memory would never
be used.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>Many common system programs (C, the editor, the assembler etc.)
create intermediate files in the /tmp directory,
so the file system where this is stored also should be made
large enough to accommodate
most high-water marks; if you have several disks, it makes
sense to mount this in a ``root'' (i.e. first partition)
file system on another disk.<tt> </tt>
All the programs that create files in /tmp take
care to delete them, but are not immune to rare events
and can leave dregs.<tt> </tt>
The directory should be examined every so often and the old
files deleted.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>The efficiency with which UNIX is able to use the CPU
is often strongly affected by the configuration of disk controllers.<tt> </tt>
For general time-sharing applications,
the best strategy is to try to split the most actively-used sections
among several disk arms.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>It is critical for good performance to balance disk load.<tt> </tt>
There are at least five components of the disk load that you can
divide between the available disks:
<dl><dt><dd>
1. The root file system.
<br>
2. The /tmp file system.
<br>
3. The /usr file system.
<br>
4. The user files.
<br>
5. The swapping activity.
<br>
</dl>
The following possibilities are ones that have been used at times
when 2, 3 and 4 disks were available:
<pre>		   +--------------------------+
		   +----------+---------------+
		   |	      |   | disks     |
		   |what      | 2 | 3	| 4   |
		   +----------+---+-----+-----+
		   |/	      | 0 | 0	| 0   |
		   |tmp       | 1 | 2	| 3   |
		   |usr       | 1 | 1	| 1   |
		   |swapping^ | 0 | 2	| 2   |
		   |users     | 0 | 0+2 | 0+2 |
		   |archive   | x | x	| 3   |
		   +----------+---+-----+-----+
		   +--------------------------+
</pre>
</dl>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>The most important things to consider are to
even out the disk load as much as possible, and to do this by
decoupling file systems (on separate arms) between which heavy copying occurs.<tt> </tt>
Note that a long term average balanced load is not important; it is
much more important to have an instantaneously balanced
load when the system is busy.<tt> </tt>
When placing several busy file systems on the same disk,
it is helpful to group them together to minimize arm movement,
with less active file systems off to the side.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>Intelligent experimentation with a few file system arrangements can
pay off in much improved performance.  It is particularly easy to
move the root, the
/tmp
file system and the swapping area.  Note, though, that the disks
containing the root and swapping area can never be removed while UNIX is
running.  Place the
user files and the
/usr
directory as space needs dictate and experiment
with the other, more easily moved file systems.<tt> </tt>
<h2>4.9.3.&#160;<tt> </tt>Implementing a layout
</h2>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>To put a chosen disk layout into effect, you should use the
<i>newfs</i>(8)
command to create each new file system.<tt> </tt>
Each file system must also be added to the file
/etc/fstab
so that it will be checked and mounted when the system is bootstrapped.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>As an example, consider a system with RA80's.  On the first RA80, ra0,
we will put the root file system in ra0a, and the /usr
file system in ra0c, which has enough space to hold it and then some.<tt> </tt>
The /tmp directory will be part of the root file system,
as no file system will be mounted on /tmp.<tt> </tt>
If we had only one RA80, we would put user files
in the ra0c partition with the system source and binaries.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>If we had a second RA80, we would place <i>/usr</i> in ra1c.<tt> </tt>
We would put user files in ra0c, calling the file system /mnt.<tt> </tt>
We would put swap on <i>ra0b</i>.<tt> </tt>
We would keep a backup copy of the root
file system in the <b>ra1a</b> disk partition and
put /tmp on <i>ra1b</i>.<tt> </tt>
<i>/etc/fstab</i> would then contain
<dl><dt><dd>
/dev/ra0a:/:rw:1:1
<br>
/dev/ra0b::sw::
<br>
/dev/ra0c:/mnt:rw:1:2
<br>
/dev/ra1b:/tmp:rw::
<br>
/dev/ra1c:/usr:rw:1:2
<br>
</dl>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>To make the /mnt file system we would do:
<dl><dt><dd>
<b>#</b> cd /dev
<br>
<b>#</b> MAKEDEV ra1
<br>
<b>#</b> newfs ra1c ra80
<br>
(information about file system prints out)
<br>
(to specify an alternate <i>m</i> value: newfs -m # ra1c ra80)
<br>
(where # is between 1 and 31)
<br>
<b>#</b> mkdir /mnt
<br>
<b>#</b> mount /dev/ra1c /mnt
<br>
</dl>
<h2>4.10.&#160;<tt> </tt>Configuring terminals
</h2>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>If UNIX is to support simultaneous
access from directly-connected terminals other than the console,
the file <i>/etc/ttys</i> (<i>ttys</i>(5)) must be edited.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>Terminals connected via DZ11 interfaces are conventionally named <b>ttyDD</b>
where DD is a decimal number, the ``minor device'' number.<tt> </tt>
The lines on dz0 are named /dev/tty00, /dev/tty01, ... /dev/tty07.<tt> </tt>
By convention, all other terminal names are of the form <b>tty</b>CX, where
C is an alphabetic character according to the type of terminal multiplexor
and its unit number,
and X is a digit for the first ten lines on the interface
and an increasing lower case letter for the rest of the lines.<tt> </tt>
C is defined for the number of interfaces of each type listed below.<tt> </tt>
Since tty structures are approximately 78 bytes each, it is
highly doubtful that more than 3 or 4 terminal interface boards
will ever be attached to a PDP-11 (especially in a BA23 cabinet).<tt> </tt>
<dl><dt><dd>
     +------------------------------------------------------+
     |Interface 	       Number of lines	 Number of  |
     |	Type	  Characters	  per board	 Interfaces |
     +------------------------------------------------------+
     |DZ11	  see above	      8 	     10     |
     |DH11	     h-o	     16 	      8     |
     |DHU11	     S-Z	     16 	      8     |
     |pty	     p-u	     16 	      6     |
     +------------------------------------------------------+
</dl>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>To add a new terminal device, be sure the device is configured into the system
and that the special files for the device have been made by /dev/MAKEDEV.<tt> </tt>
Then, enable the appropriate lines of /etc/ttys by setting the ``status''
field to <b>on</b> (or add new lines).<tt> </tt>
Note that lines in <i>/etc/ttys</i> are one-for-one with entries
in the file of current users (<i>/var/run/utmp</i>),
and therefore it is best to make changes
while running in single-user mode
and to add all of the entries for a new device at once.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>The format of the /etc/ttys file is the same in 2.11BSD as in 2.10BSD and 4.3BSD.<tt> </tt>
Each line in the file is broken into four tab separated
fields (comments are shown by a `#' character and extend to
the end of the line).  For each terminal line the four fields
are:
the device (without a leading /dev),
the program /etc/init should startup to service the line
(or <b>none</b> if the line is to be left alone),
the terminal type (found in /etc/termcap),
and optional status information describing if the terminal is
enabled or not and if it is ``secure'' (i.e. the super user should
be allowed to login on the line).  All fields are character strings
with entries requiring embedded white space enclosed in double
quotes.<tt> </tt>
Thus a newly added terminal /dev/tty00 could be added as
<dl><dt><dd>
tty00 	"/usr/libexec/getty std.9600"	vt100	on secure	# Steve's office
<br>
</dl>
The std.9600 parameter provided
to /usr/libexec/getty is used in searching the file /etc/gettytab; it specifies
a terminal's characteristics (such as baud rate).<tt> </tt>
To make custom terminal types, consult 
<i>gettytab</i>(5)
before modifying /etc/gettytab.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>Dialup terminals should be wired so that carrier is asserted only when the
phone line is dialed up.<tt> </tt>
For non-dialup terminals from which modem control
is not available, you must either wire back the signals so that
the carrier appears to always be present, or show in the minor device number
that carrier is to be assumed to be present
by adding 128 decimal to the minor device number when creating the
device node.  This differs from 4.3BSD where the softcarrier state is
specified at kernel configuration time.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>For network terminals (i.e. pseudo terminals), no program should
be started up on the lines.  Thus, the normal entry in /etc/ttys
would look like
<dl><dt><dd>
ttyp0 	none	network
<br>
</dl>
(Note the fourth field is not needed here.)
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>When the system is running multi-user, all terminals that are listed
in /etc/ttys as <b>on</b> have their line are enabled.<tt> </tt>
If, during normal operations, it is desired
to disable a terminal line, you can edit the file
/etc/ttys
to change the terminal's status to <b>off</b> and
then send a hangup signal to the <i>init</i> process, by doing
<dl><dt><dd>
<b>#</b> kill -1 1
<br>
</dl>
Terminals can similarly be enabled by changing the status field
from <b>off</b> to <b>on</b> and sending a hangup signal to <i>init</i>.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>Note that if a special file is inaccessible when <i>init</i> tries
to create a process for it, init will log a message to the
system error logging process (/usr/sbin/syslogd)
and try to reopen the terminal every minute, reprinting the warning
message every 10 minutes.  Messages of this sort are normally
printed on the console, though other actions may occur depending
on the configuration information found in /etc/syslog.conf.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>Finally note that you should change the names of any dialup
terminals to ttyd?<tt> </tt>
where ? is in [0-9a-zA-Z], as some programs use this property of the
names to determine if a terminal is a dialup.<tt> </tt>
Shell commands to do this should be put in the /dev/MAKEDEV.local
script.<tt> </tt>
<h2>4.11.&#160;<tt> </tt>Adding users
</h2>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>New users can be added to the system by adding a line to the
password file
/etc/passwd.<tt> </tt>
The procedure for adding a new user is described in
<i>adduser</i>(8).<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>You should add accounts for the initial user community, giving
each a directory and a password, and putting users who will wish
to share software in the same groups.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>Several guest accounts have been provided on the distribution
system; these accounts are for people at Berkeley, 
Bell Laboratories, and others
who have done major work on UNIX in the past.  You can delete these accounts,
or leave them on the system if you expect that these people would have
occasion to login as guests on your system.<tt> </tt>
<h2>4.12.&#160;<tt> </tt>Site tailoring
</h2>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>All programs that require the site's name, or some similar
characteristic, obtain the information through system calls
or from files located in /etc.  Aside from parts of the
system related to the network, to tailor the system to your
site you must simply select a site name, then edit the file
<dl><dt><dd>
/etc/netstart
<br>
</dl>
At or about line 25 in /etc/netstart you should find a line similar to:
<dl><dt><dd>
/bin/hostname <i>myname.my.domain</i>
<br>
</dl>
defines the value returned by the 
<i>gethostname</i>(2)
system call.  Your hostname should be your fully qualified 
domain name.  Programs such as
<i>getty</i>(8),
<i>mail</i>(1),
<i>wall</i>(1),
<i>uucp</i>(1),
and
<i>who</i>(1)
use this system call so that the binary images are site
independent.<tt> </tt>
<h2>4.13.&#160;<tt> </tt>Setting up the mail system
</h2>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>The mail system consists of the following commands:
<dl><dt><dd>
/bin/mail	      old standard mail program, binmail(1)
/usr/ucb/mail	      UCB mail program, described in mail(1)
/usr/sbin/sendmail    mail routing program
/usr/spool/mail       mail spooling directory
/etc/aliases	      mail forwarding information
/usr/bin/newaliases   command to rebuild binary forwarding database
/usr/ucb/biff	      mail notification enabler^
/usr/libexec/comsat   mail notification daemon^
</dl>
Mail is normally sent and received using the
<i>mail</i>(1)
command, which provides a front-end to edit the messages sent
and received, and passes the messages to
<i>sendmail</i>(8)
for routing.<tt> </tt>
The routing algorithm uses knowledge of the network name syntax,
aliasing and forwarding information, and network topology, as
defined in the configuration file /etc/sendmail.cf, to
process each piece of mail.<tt> </tt>
Local mail is delivered by giving it to the program /bin/mail
that adds it to the mailboxes in the directory /usr/spool/mail/<i>username</i>,
using a locking protocol to avoid problems with simultaneous updates.<tt> </tt>
After the mail is delivered, the local mail delivery daemon /usr/libexec/comsat
is notified, which in turn notifies
users who have issued a ``<i>biff</i> y'' command that mail has arrived\(ua.<tt> </tt>
</dl>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>To set up the mail facility you should read the instructions in the
file READ_ME in the directory /usr/src/usr.lib/sendmail and then adjust
the necessary configuration files.<tt> </tt>
You should also set up the file /etc/aliases for your installation,
creating mail groups as appropriate.  Documents describing 
<i>sendmail</i>'s
operation and installation are also included on the distribution tape.<tt> </tt>
<h2>4.13.1.&#160;<tt> </tt>Setting up a UUCP connection
</h2>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>The version of <i>uucp</i> included in 2.11BSD is an
enhanced version of the one originally distributed with 32/V\(ua.<tt> </tt>
The enhancements include:
<dt>+<dd>
support for many auto call units and dialers
in addition to the DEC DN11,
<dt>+<dd>
breakup of the spooling area into multiple subdirectories,
<dt>+<dd>
addition of an <i>L.cmds</i> file to control the set
of commands that may be executed by a remote site,
<dt>+<dd>
enhanced ``expect-send'' sequence capabilities when
logging in to a remote site,
<dt>+<dd>
new commands to be used in polling sites and
obtaining snap shots of <i>uucp</i> activity,
<dt>+<dd>
additional protocols for different communication media.<tt> </tt>
</dl>
<p>
This section gives a brief overview of <i>uucp</i>
and points out the most important steps in its installation.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>To connect two UNIX machines with a <i>uucp</i> network link using modems,
one site must have an automatic call unit
and the other must have a dialup port.<tt> </tt>
It is better if both sites have both.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>You should first read the paper in the UNIX System Manager's Manual:
``Uucp Implementation Description''.<tt> </tt>
It describes in detail the file formats and conventions,
and will give you a little context.<tt> </tt>
In addition,
the document ``setup.tblms'',
located in the directory /usr/src/usr.bin/uucp/UUAIDS,
may be of use in tailoring the software to your needs.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>The <i>uucp</i> support is located in three major directories:
/usr/bin,
/etc/uucp,
and /usr/spool/uucp.<tt> </tt>
User commands are kept in /usr/bin,
operational commands in /etc/uucp,
and /usr/spool/uucp is used as a spooling area.<tt> </tt>
The commands in /usr/bin are:
<dl><dt><dd>
/usr/bin/uucp	    file-copy command
/usr/bin/uux	    remote execution command
/usr/bin/uusend     binary file transfer using mail
/usr/bin/uuencode   binary file encoder (for uusend)
/usr/bin/uudecode   binary file decoder (for uusend)
/usr/bin/uulog	    scans session log files
/usr/bin/uusnap     gives a snap-shot of uucp activity
/usr/bin/uupoll     polls remote system until an answer is received
/usr/bin/uuname     prints a list of known uucp hosts
/usr/bin/uuq	    gives information about the queue
</dl>
The important files and commands in /etc/uucp are:
<dl><dt><dd>
/etc/uucp/L-devices	list of dialers and hard-wired lines
/etc/uucp/L-dialcodes	dialcode abbreviations
/etc/uucp/L.aliases	hostname aliases
/etc/uucp/L.cmds	commands remote sites may execute
/etc/uucp/L.sys 	systems to communicate with, how to connect, and when
/etc/uucp/SEQF		sequence numbering control file
/etc/uucp/USERFILE	remote site pathname access specifications
/usr/sbin/uucico	uucp protocol daemon
/etc/uucp/uuclean	cleans up garbage files in spool area
/usr/libexec/uuxqt	uucp remote execution server
</dl>
while the spooling area contains the following important files and directories:
<dl><dt><dd>
/usr/spool/uucp/C.	     directory for command, ``C.'' files
/usr/spool/uucp/D.	     directory for data, ``D.'', files
/usr/spool/uucp/X.	     directory for command execution, ``X.'', files
/usr/spool/uucp/D.machine    directory for local ``D.'' files
/usr/spool/uucp/D.machineX   directory for local ``X.'' files
/usr/spool/uucp/TM.	     directory for temporary, ``TM.'', files
/usr/spool/uucp/LOGFILE      log file of uucp activity
/usr/spool/uucp/SYSLOG	     log file of uucp file transfers
</dl>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>To install <i>uucp</i> on your system,
start by selecting a site name.<tt> </tt>
A <i>uucp</i> account must be created in the password file and a password set up.<tt> </tt>
Then,
create the appropriate spooling directories with mode 755
and owned by user <i>uucp</i>, group <i>daemon</i>.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>If you have an auto-call unit,
the L.sys, L-dialcodes, and L-devices files should be created.<tt> </tt>
The L.sys file should contain
the phone numbers and login sequences
required to establish a connection with a <i>uucp</i> daemon on another machine.<tt> </tt>
For example, my L.sys file looks something like:
<p>
<dl><dt><dd>
elisa Any ACU 1200 7064297  "" \\r\\c ogin-EOT-ogin-\\r\\c-ogin xelisa assword: XXX
<br>
etn-ra Any ACU 1200 8891237  "" \\r\\c ogin nuucp assword XXX
<br>
anagld Never ACU 2400 8894517 name:-EOT-name: uucp assword: XXX
<br>
</dl>
<p>
The first field is the name of a site,
the second shows when the machine may be called,
the third field specifies how the host is connected
(through an ACU, a hard-wired line, etc.),
then comes the phone number to use in connecting through an auto-call unit,
and finally a login sequence.<tt> </tt>
The phone number
may contain common abbreviations that are defined in the L-dialcodes file.<tt> </tt>
The device specification should refer to devices
specified in the L-devices file.<tt> </tt>
Listing only ACU causes the <i>uucp</i> daemon, <i>uucico</i>,
to search for any available auto-call unit in L-devices.<tt> </tt>
Our L-dialcodes file is of the form:
<dl><dt><dd>
ny	1-315-
<br>
nj	1-201-
<br>
bostn	1-617-
<br>
</dl>
while our L-devices file is:
<dl><dt><dd>
ACU cul0 unused 1200 ventel
<br>
</dl>
Refer to the README file in the <i>uucp</i> source directory
for more information about installation.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>As <i>uucp</i> operates it creates (and removes) many small
files in the directories underneath /usr/spool/uucp.<tt> </tt>
Sometimes files are left undeleted;
these are most easily purged with the <i>uuclean</i> program.<tt> </tt>
The log files can grow without bound unless trimmed back;
<i>uulog</i> maintains these files.<tt> </tt>
Many useful aids in maintaining your <i>uucp</i> installation
are included in a subdirectory UUAIDS beneath /usr/src/usr.bin/uucp.<tt> </tt>
Peruse this directory and read the ``setup'' instructions also located there.<tt> </tt>
<!--  Copyright (c) 1980 Regents of the University of California. -->
<!--  All rights reserved.  The Berkeley software License Agreement -->
<!--  specifies the terms and conditions for redistribution. -->
<!-- 	@(#)5.t	2.5 (2.11BSD GTE) 1996/11/16 -->
<p>
<br>
<b>
</b><b><center>5. NETWORK SETUP
<br>
</center>
</b><b></b><p>
<p>
<b></b>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>The following section has been lightly edited to correspond to
the current 2.11BSD networking.  Several parts of it do not really apply to
2.11BSD, for example, it is unlikely that anyone will connect a PDP-11 to
an IMP but it is possible as the LH/DH-11 networking interface and
the IMP modules have been ported and lightly tested, or that anyone will 
run the nameserver.<tt> </tt>
The ``correct''
use of the networking in 2.11BSD is probably with a list of the local net
addresses in the <i>/etc/hosts</i> file and with one default gateway for
all network traffic.  In particular, do not run
<i>routed</i>(8)
unless you're extremely sure that you know what you're doing.  This is
doubly true if SL/IP is being used as the primary connection to the
outside world.<tt> </tt>
The IMP and PRONET drivers are known to work, but 
long term robustness is unknown.<tt> </tt>
Sites that wish to hook 2.11BSD into more than a simple
local ethernet may have some work ahead of them.  If any additional
drivers are ported, I would really like a copy.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>The networking in 2.11BSD, runs in supervisor
mode, separate from the mainstream kernel.  There is room without overlaying
to hold both a SL/IP and ethernet driver.  This is a major win, as
it allows the networking to maintain its mbufs in normal data space,
among other things.  The networking portion of the kernel resides in
``/netnix'', and is
loaded after the kernel is running.  Since the kernel only looks for the
file ``/netnix'', it will not run if it is unable to load ``/netnix''
, sites should build and keep a non-networking kernel in ``/'' at all times,
as a backup.  <b>NOTE</b>:  The ``/unix'' and ``/netnix'' imagines must
have been created at the same time, do not attempt to use mismatched
images.   The ability to have <b>boot</b> tell the kernel which network image
to load is on the wish list (had to have something take the place of
wishing for disklabels ;-)).<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>2.11BSD provides support for the DARPA standard Internet
protocols IP, ICMP, TCP, and UDP.  These protocols may be used
on top of a variety of hardware devices ranging from the
IMP's (PSN's) used in the Internet to local area network controllers
for the Ethernet.  Network services are split between the
kernel (communication protocols) and user programs (user
services such as TELNET and FTP).  This section describes
how to configure your system to use the Internet networking support.<tt> </tt>
2.11BSD also includes code to support the Xerox Network Systems (NS)
protocols; the basic porting work has been done, but it is completely
untested.<tt> </tt>
<h2>4.14.&#160;<tt> </tt>System configuration
</h2>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>To configure the kernel to include the Internet communication
protocols, define the INET option.  This automatically defines
the NLOOP option.  TCP_COMPAT_42 is always defined.  Xerox NS support is
enabled with the NS option.<tt> </tt>
In either case, include the pseudo-device
``pty'' in your machine's configuration
file, using the NPTY options.<tt> </tt>
The ``pty'' pseudo-device forces the pseudo terminal device driver
to be configured into the system, see <i>pty</i>(4).  The NLOOP
option forces inclusion of the software loopback interface driver.<tt> </tt>
The loop driver is used in network testing as well as for the
system talking to itself rather than transmitting the data over the wire.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>If you are planning to use the Internet network facilities on a 10Mb/s
Ethernet, the pseudo-device ``ether'' should also be included
in the configuration using the NETHER option; this forces inclusion of
the Address Resolution Protocol module used in mapping between 48-bit
Ethernet and 32-bit Internet addresses.  Also, if you have an IMP
connection, you will need to include the pseudo-device ``imp'', using
the option NIMP.  The IMP software is ported and is in use at at least
one site.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>Before configuring the appropriate networking hardware, you should
consult the manual pages in section 4 of the Programmer's Manual.<tt> </tt>
The following table lists the devices for which software support
exists.  Again, much of this software is unported and untested; only
the basic networking has been stressed at all.  Many other devices
are available, but unported.  Porting should simply be a matter of
making the hardware device work.  The directories ``/sys/pdpif'' and
``/sys/vaxif'' contain many drivers.  The ones in ``pdpif'' are
either the current, working drivers, or drivers that, at some time,
worked on PDP-11's.  The ones in ``vaxif'' are the current VAX drivers,
and, as such, will have to have their memory usage changed, but serve
as an excellent example of how the hardware works.<tt> </tt>
<dl><dt><dd>
Device name   Manufacturer and product
------------------------------------------------------------------
de	      DEC DEUNA/DELUA 10Mb/s Ethernet
qe	      DEC DEQNA 10Mb/s Ethernet
qt	      DEC DELQA-YM 10Mb/s Ethernet
ec	      3Com 10Mb/s Ethernet
il	      Interlan 1010 and 10101A 10Mb/s Ethernet interfaces
vv	      Proteon ProNET - Token Ring Interface
acc	      LH/DH-11 1822 IMP/PSN Interface
</dl>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>SL/IP is also available.  It is surprisingly efficient.  Over a 9600 baud
line it is not unusual to see <b>ftp</b> rates in the 800 bytes per second
range (depending how busy the system is).<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>All network interface drivers including the loopback interface,
require that their host address(es) be defined at boot time.<tt> </tt>
This is done with
<i>ifconfig</i>(8)
commands included in the <i>/etc/rc.local</i> file.<tt> </tt>
Interfaces that are able to dynamically deduce the host
part of an address may check that the host part of the address is correct.<tt> </tt>
The manual page for each network interface
describes the method used to establish a host's address.<tt> </tt>
<i>Ifconfig</i>(8)
can also be used to set options for the interface at boot time.<tt> </tt>
Options are set independently for each interface, and
apply to all packets sent using that interface.<tt> </tt>
These options include disabling the use of the Address Resolution Protocol;
this may be useful if a network is shared with hosts running software
that does not yet provide this function.<tt> </tt>
Alternatively, translations for such hosts may be set in advance
or ``published'' by a 2.11BSD host by use of the
<i>arp</i>(8)
command.  Note that the use of trailer link-level is now negotiated
between 2.11BSD hosts using ARP, and it is thus no longer necessary to
disable the use of trailers with <i>ifconfig</i>.  It is <b>STRONGLY</b>
recommended, however, that 2.11BSD networking be run without trailers,
as the trailer code in most of the drivers has either been removed,
commented out, is untested or is <b>known</b> not to work.  This is a problem 
with certain releases of <i>Ultrix</i>, which has to be explicitly configured
not to send trailers if it and 2.11BSD are to coexist.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>To use the pseudo terminals just configured, device
entries must be created in the ``/dev'' directory.  To create 32
pseudo terminals (plenty, you can probably get by with many less)
execute the following commands.<tt> </tt>
<dl><dt><dd>
<b>#</b> cd /dev
<br>
<b>#</b> MAKEDEV pty0 pty1
<br>
</dl>
More pseudo terminals may be made by specifying <i>pty2</i>, <i>pty3</i>,
etc.  The kernel normally includes support for 16 pseudo terminals
unless the configuration file specifies a different number.<tt> </tt>
Each pseudo terminal really consists of two files in /dev:
a master and a slave.  The master pseudo terminal file is named
/dev/ptyp?, while the slave side is /dev/ttyp?.  Pseudo terminals
are also used by several programs not related to the network.  <b>NOTE</b>:
the terminal structures are 78 bytes each, declaring more than 16 pseudo
terminals is potentially wasteful of kernel D space.  See the comment
in the kernel config files.<tt> </tt>
In addition to creating the pseudo terminals,
be sure to install them in the
<i>/etc/ttys
</i>file (with a `none' in the second column so no
<i>getty
</i>is started).<tt> </tt>
<h2>4.15.&#160;<tt> </tt>Local subnetworks
</h2>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>In 2.11BSD the DARPA Internet support
includes the notion of ``subnetworks''.  This is a mechanism
by which multiple local networks may appears as a single Internet
network to off-site hosts.  Subnetworks are useful because
they allow a site to hide their local topology, requiring only a single
route in external gateways;
it also means that local network numbers may be locally administered.<tt> </tt>
The standard describing this change in Internet addressing is RFC-950.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>To set up local subnetworks one must first decide how the available
address space (the Internet ``host part'' of the 32-bit address)
is to be partitioned.<tt> </tt>
Sites with a class A network
number have a 24-bit address space with which to work,
sites with a class B network number have a 16-bit address space,
while sites with a class C network number have an 8-bit address space\(ua.<tt> </tt>
To define local subnets you must steal some bits
from the local host address space for use in extending the network
portion of the Internet address.  This reinterpretation of Internet
addresses is done only for local networks; i.e. it is not visible
to hosts off-site.  For example, if your site has a class B network
number, hosts on this network have an Internet address that contains
the network number, 16 bits, and the host number, another
16 bits.  To define 254 local subnets, each
possessing at most 255 hosts, 8 bits may be taken from the local part.<tt> </tt>
(The use of subnets 0 and all-1's, 255 in this example, is discouraged
to avoid confusion about broadcast addresses.)
These new network
numbers are then constructed by concatenating the original 16-bit network
number with the extra 8 bits containing the local subnetwork number.<tt> </tt>
</dl>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>The existence of local subnetworks is communicated to the system at the time a
network interface is configured with the
<i>netmask
</i>option to the
<i>ifconfig
</i>program.  A ``network mask'' is specified to define the
portion of the Internet address that is to be considered the network part
for that network.<tt> </tt>
This mask normally contains the bits corresponding to the standard
network part as well as the portion of the local part
that has been assigned to subnets.<tt> </tt>
If no mask is specified when the address is set,
it will be set according to the class of the network.<tt> </tt>
For example, at Berkeley (class B network 128.32) 8 bits
of the local part have been reserved for defining subnetworks;
consequently the /etc/rc.local file contains lines of the form
<dl><dt><dd>
ifconfig en0 netmask 0xffffff00 128.32.1.7
<br>
</dl>
This specifies that for interface ``en0'', the upper 24 bits of
the Internet address should be used in calculating network numbers
(netmask 0xffffff00), and the interface's Internet address is
``128.32.1.7'' (host 7 on network 128.32.1).  Hosts <i>m</i> on
sub-network <i>n</i> of this network would then have addresses of
the form ``128.32.<i>n</i>.<i>m</i>'';  for example, host
99 on network 129 would have an address ``128.32.129.99''.<tt> </tt>
For hosts with multiple interfaces, the network mask should
be set for each interface,
although in practice only the mask of the first interface on each network
is actually used.<tt> </tt>
<h2>4.16.&#160;<tt> </tt>Internet broadcast addresses
</h2>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>The address defined as the broadcast address for Internet networks
according to RFC-919 is the address with a host part of all 1's.<tt> </tt>
The address used by 4.2BSD was the address with a host part of 0.<tt> </tt>
2.11BSD uses the standard broadcast address (all 1's) by default,
but allows the broadcast address to be set (with <i>ifconfig</i>)
for each interface.<tt> </tt>
This allows networks consisting of both 4.2BSD and 2.11BSD hosts
to coexist.<tt> </tt>
In the presence of subnets, the broadcast address uses the subnet field
as for normal host addresses, with the remaining host part set to 1's
(or 0's, on a network that has not yet been converted).<tt> </tt>
2.11BSD hosts recognize and accept packets
sent to the logical-network broadcast address as well as those sent
to the subnet broadcast address, and when using an all-1's broadcast,
also recognize and receive packets sent to host 0 as a broadcast.<tt> </tt>
<h2>4.17.&#160;<tt> </tt>Routing
</h2>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>If your environment allows access to networks not directly
attached to your host you will need to set up routing information
to allow packets to be properly routed.  Two schemes are
supported by the system.  The first scheme
employs the routing table management daemon <i>routed</i>
to maintain the system routing tables.  The routing daemon
uses a variant of the Xerox Routing Information Protocol
to maintain up to date routing tables in a cluster of local
area networks.  By using the <i>/etc/gateways</i>
file created by
<i>htable</i>(8),
the routing daemon can also be used to initialize static routes
to distant networks (see the next section for further discussion).<tt> </tt>
When the routing daemon is started up
(usually from <i>/etc/rc.local</i>) it reads <i>/etc/gateways</i> if it exists
and installs those routes defined there, then broadcasts on each local network
to which the host is attached to find other instances of the routing
daemon.  If any responses are received, the routing daemons
cooperate in maintaining a globally consistent view of routing
in the local environment.  This view can be extended to include
remote sites also running the routing daemon by setting up suitable
entries in <i>/etc/gateways</i>; consult
<i>routed</i>(8)
for a more thorough discussion.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>The second approach is to define a default or wildcard
route to a smart
gateway and depend on the gateway to provide ICMP routing
redirect information to dynamically create a routing data
base.  This is done by adding an entry of the form
<dl><dt><dd>
route add default <i>smart-gateway</i> 1
<br>
</dl>
to <i>/etc/rc.local</i>; see
<i>route</i>(8)
for more information.  The default route
will be used by the system as a ``last resort''
in routing packets to their destination.  Assuming the gateway
to which packets are directed is able to generate the proper
routing redirect messages, the system will then add routing
table entries based on the information supplied.  This approach
has certain advantages over the routing daemon, but is
unsuitable in an environment where there are only bridges (i.e.<tt> </tt>
pseudo gateways that, for instance, do not generate routing
redirect messages).  Further, if the
smart gateway goes down there is no alternative, save manual
alteration of the routing table entry, to maintaining service.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>The system always listens, and processes, routing redirect
information, so it is possible to combine both of the above
facilities.  For example, the routing table management process
might be used to maintain up to date information about routes
to geographically local networks, while employing the wildcard
routing techniques for ``distant'' networks.  The
<i>netstat</i>(1)
program may be used to display routing table contents as well
as various routing oriented statistics.  For example,
<dl><dt><dd>
<b>#</b>netstat -r
<br>
</dl>
will display the contents of the routing tables, while
<dl><dt><dd>
<b>#</b>netstat -r -s
<br>
</dl>
will show the number of routing table entries dynamically
created as a result of routing redirect messages, etc.<tt> </tt>
<h2>4.18.&#160;<tt> </tt>Use of 2.11BSD machines as gateways
</h2>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>Only sheer insanity could prompt the use of 2.11BSD machines as gateways.<tt> </tt>
If you <b>really</b> want to do this then the best recourse is to
prowl the sources and see what has to be done.  The code is all there,
and the "ipforwarding" variable is present.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>Local area routing within a group of interconnected Ethernets
and other such networks may be handled by
<i>routed</i>(8).<tt> </tt>
Gateways between the Internet and one or more local networks
require an additional routing protocol, the Exterior Gateway Protocol (EGP),
to inform the core gateways of their presence
and to acquire routing information from the core.<tt> </tt>
<h2>4.19.&#160;<tt> </tt>Network servers
</h2>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>In 2.11BSD most of the server programs are started up by a
``super server'', the Internet daemon.  The Internet
daemon, <i>inetd</i>, acts as a master server for
programs specified in its configuration file, <i>/etc/inetd.conf</i>,
listening for service requests for these servers, and starting
up the appropriate program whenever a request is received.<tt> </tt>
The configuration file contains lines containing a service
name (as found in <i>/etc/services</i>), the type of socket the
server expects (e.g. stream or dgram), the protocol to be
used with the socket (as found in <i>/etc/protocols</i>), whether
to wait for each server to complete before starting up another,
the user name as which the server should run, the server
program's name, and at most five arguments to pass to the
server program.<tt> </tt>
Some trivial services are implemented internally in <i>inetd</i>,
and their servers are listed as ``internal.''
For example, an entry for the file
transfer protocol server would appear as
<dl><dt><dd>
ftp	stream	tcp	nowait	root	/usr/libexec/ftpd	ftpd -l
<br>
</dl>
or if you are using the <i>tcp_wrapper</i> program as
<dl><dt><dd>
ftp	stream	tcp	nowait	root	/usr/libexec/tcpd	ftpd -l
<br>
</dl>
Consult
<i>inetd</i>(8)
for more detail on the format of the configuration file
and the operation of the Internet daemon.<tt> </tt>
<h2>4.20.&#160;<tt> </tt>Network data bases
</h2>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>Several data files are used by the network library routines
and server programs.  Most of these files are host independent
and updated only rarely.<tt> </tt>
<dl><dt><dd>
File		   Manual reference   Use
-------------------------------------------------------------------------------
/etc/hosts	   hosts(5)	      host names
/etc/networks	   networks(5)	      network names
/etc/services	   services(5)	      list of known services
/etc/protocols	   protocols(5)       protocol names
/etc/hosts.equiv   rshd(8)	      list of ``trusted'' hosts
/etc/rc.local	   rc(8)	      command script for starting servers
/etc/ftpusers	   ftpd(8)	      list of ``unwelcome'' ftp users
/etc/hosts.lpd	   lpd(8)	      list of hosts allowed to access printers
/etc/inetd.conf    inetd(8)	      list of servers started by inetd
</dl>
The files distributed are set up for Internet hosts.<tt> </tt>
Local networks and hosts should be added to describe the local
configuration.<tt> </tt>
Network numbers will have to be chosen for each Ethernet.<tt> </tt>
For sites not connected to the Internet,
these can be chosen more or less arbitrarily,
otherwise the normal channels should be used for allocation of network
numbers.<tt> </tt>
<h2>4.20.1.&#160;<tt> </tt>Regenerating /etc/hosts and /etc/networks
</h2>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>When using the host address routines that use the Internet name server,
the file <i>/etc/hosts</i> is only used for setting interface addresses
and at other times that the server is not running,
and therefore it need only contain addresses for local hosts.<tt> </tt>
There is no equivalent service for network names yet.<tt> </tt>
The days of retrieving a host file containing all systems on the Internet
are over.  Besides, you would grow very old and run out of disk space
while waiting for <i>mkhosts</i>(8) to process a hosts file containing
the several million entries.<tt> </tt>
Therefore the details of retrieving a master hosts file using
<i>htable</i>(8)
and 
<i>gettable</i>(8)
have been removed from this document.  However if you do use local hosts
files you will still need to run 
<i>mkhosts</i>(8)
and this is described below.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>If you are using the host table for host name and address
mapping, you should run <i>mkhosts</i>(8) after installing
<i>/etc/hosts</i>.<tt> </tt>
The <i>mkhosts</i>(8) program has been enhanced for 2.11BSD to allow
multiple addresses per host.  The order in which the addresses are
given in <i>/etc/hosts</i> is preserved, so the entries for a given
host should be in order of importance.<tt> </tt>
If you are using the name server for the host name and address mapping,
you only need to install <i>networks</i> and a small copy of <i>hosts</i>
describing your local machines.  The full host table in this case might
be placed somewhere else for reference by users.<tt> </tt>
The gateways file may be installed in <i>/etc/gateways</i> if you use
<i>routed</i>(8)
for local routing and wish to have static external routes installed
when <i>routed</i> is started.<tt> </tt>
This procedure is essentially obsolete, however, except for individual hosts
that are on the Milnet and do not forward packets from a local
network.<tt> </tt>
Other situations require the use of <b>gated</b>.<tt> </tt>
That program can never be made to run on a PDP-11 due to address space
considerations.  Also, the networking code
could not even begin to handle the number of routes which would be received.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>If you are connected to the Internet, it is highly recommended that
you use the name server resolver routines for your host name and address
mapping, as this provides access to a much larger set of hosts than are
provided in the host table.  Many large organization on the network,
currently have only a small percentage of their hosts listed in the host
table retrieved from NIC.<tt> </tt>
<h2>4.20.2.&#160;<tt> </tt>/etc/hosts.equiv
</h2>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>The remote login and shell servers use an
authentication scheme based on trusted hosts.  The <i>hosts.equiv</i>
file contains a list of hosts that are considered trusted
and, under a single administrative control.  When a user
contacts a remote login or shell server requesting service,
the client process passes the user's name and the official
name of the host on which the client is located.  In the simple
case, if the host's name is located in <i>hosts.equiv</i> and
the user has an account on the server's machine, then service
is rendered (i.e. the user is allowed to log in, or the command
is executed).  Users may expand this ``equivalence'' of
machines by installing a <i>.rhosts</i> file in their login directory.<tt> </tt>
The root login is handled specially, bypassing the <i>hosts.equiv</i>
file, and using only the <i>/.rhosts</i> file.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>Thus, to create a class of equivalent machines, the <i>hosts.equiv</i>
file should contain the <i>official</i> names for those machines.<tt> </tt>
If you are running the name server, you may omit the domain part
of the host name for machines in your local domain.<tt> </tt>
For example, several machines on my local
network are considered trusted, so the <i>hosts.equiv</i> file is
of the form:
<dl><dt><dd>
wlv
<br>
wlonex
<br>
wlonex0
<br>
wlbr
<br>
</dl>
<h2>4.20.3.&#160;<tt> </tt>/etc/rc.local
</h2>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>Most network servers are automatically started up at boot time
by the command file /etc/rc (if they are installed in their
presumed locations) or by the Internet daemon (see above).<tt> </tt>
These include the following:
<dl><dt><dd>
Program    Server			     Started by
--------------------------------------------------------
rshd	   shell server 		     inetd
rexecd	   exec server			     inetd
rlogind    login server 		     inetd
telnetd    TELNET server		     inetd
ftpd	   FTP server			     inetd
fingerd    Finger server		     inetd
tftpd	   TFTP server			     inetd
rwhod	   system status daemon 	     /etc/rc
syslogd    error logging server 	     /etc/rc
sendmail   SMTP server			     /etc/rc
routed	   routing table management daemon   /etc/rc
</dl>
Consult the manual pages and accompanying documentation (particularly
for sendmail) for details about their operation.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>To have other network servers started up as well,
the appropriate line should be added
to the Internet daemon's configuration file <i>/etc/inetd.conf</i>, or
commands similar to the following should be placed in the site dependent
file <i>/etc/rc.local</i>.<tt> </tt>
<dl><dt><dd>
if [ -f /usr/sbin/rwhod ]; then
<br>
	rwhod &amp; echo -n ' rwhod'			&gt;/dev/console
<br>
fi
<br>
</dl>
<h2>4.20.4.&#160;<tt> </tt>/etc/ftpusers
</h2>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>The FTP server included in the system provides support for an
anonymous FTP account.  Because of the inherent security problems
with such a facility you should read this section carefully if
you consider providing such a service.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>An anonymous account is enabled by creating a user <i>ftp</i>.<tt> </tt>
When a client uses the anonymous account a <i>chroot</i>(2)
system call is performed by the server to restrict the client
from moving outside that part of the file system where the
user ftp home directory is located.  Because a <i>chroot</i> call
is used, certain programs and files used by the server 
process must be placed in the ftp home directory. 
Further, one must be
sure that all directories and executable images are unwritable.<tt> </tt>
The following directory setup is recommended.<tt> </tt>
<dl><dt><dd>
<b>#</b> cd ~ftp
<br>
<b>#</b> chmod 555 .; chown ftp .; chgrp ftp .
<br>
<b>#</b> mkdir bin etc pub
<br>
<b>#</b> chown root bin etc
<br>
<b>#</b> chmod 555 bin etc
<br>
<b>#</b> chown ftp pub
<br>
<b>#</b> chmod 777 pub
<br>
<b>#</b> cd bin
<br>
<b>#</b> cp /bin/sh /bin/ls .
<br>
<b>#</b> chmod 111 sh ls
<br>
<b>#</b> cd ../etc
<br>
<b>#</b> cp /etc/passwd /etc/group .
<br>
<b>#</b> chmod 444 passwd group
<br>
</dl>
When local users wish to place files in the anonymous
area, they must be placed in a subdirectory.  In the
setup here, the directory <i>~ftp/pub</i> is used.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>NOTE: Mode 777 on the 'pub' directory can and has been abused!  Changing the
mode to 555 is a good choice but would require administrative assistance for
placing files in the 'pub' directory.  Probably not a bad idea though.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>Another issue to consider is the copy of <i>/etc/passwd</i>
placed here.  It may be copied by users who use the
anonymous account.  They may then try to break the 
passwords of users on your machine for further access.<tt> </tt>
A good choice of users to include in this copy might
be root, daemon, uucp, and the ftp user.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>Aside from the problems of directory modes and such,
the ftp server may provide a loophole for interlopers
if certain user accounts are allowed.<tt> </tt>
The file <i>/etc/ftpusers</i> is checked on each connection.<tt> </tt>
If the requested user name is located in the file, the
request for service is denied.  This file normally has
the following names on our systems.<tt> </tt>
<dl><dt><dd>
uucp
<br>
root
<br>
</dl>
Accounts with nonstandard shells should be listed in
this file.  Accounts without passwords
need not be listed in this file, the ftp server will
not service these users.<tt> </tt>
<!--  Copyright (c) 1980 Regents of the University of California. -->
<!--  All rights reserved.  The Berkeley software License Agreement -->
<!--  specifies the terms and conditions for redistribution. -->
<!-- 	@(#)6.t	2.4 (2.11BSD GTE) 1996/11/16 -->
<br>
<b>
</b><b><center>6. SYSTEM OPERATION
<br>
</center>
</b><b></b><p>
<p>
<b></b>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>This section describes procedures used to operate a PDP-11 UNIX system.<tt> </tt>
Procedures described here are used periodically, to reboot the system,
analyze error messages from devices, do disk backups, monitor
system performance, recompile system software and control local changes.<tt> </tt>
<h2>4.21.&#160;<tt> </tt>Bootstrap and shutdown procedures
</h2>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>In a normal reboot, the system checks the disks and comes up multi-user
without intervention at the console.<tt> </tt>
Such a reboot
can be stopped (after it prints the date) with a ^C (interrupt).<tt> </tt>
This will leave the system in single-user mode, with only the console
terminal active.<tt> </tt>
It is also possible to allow the filesystem checks to complete
and then to return to single-user mode by signaling <i>fsck</i>
with a QUIT signal (^\).<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>If booting from the console command level is needed, then the command
<dl><dt><dd>
<b>&gt;&gt;&gt;</b> B
<br>
</dl>
will boot from the default device and
ask for the name of the system to be booted.<tt> </tt>
Other systems such as the 11/44 require a device name to be given:
<dl><dt><dd>
<b>&gt;&gt;&gt;</b> B DU
<br>
</dl>
to boot from a MSCP/UDA device.<tt> </tt>
Typing a carriage return will cause the default system (as compiled in
in section 4.1), to be booted.<tt> </tt>
In any case, the system selected will come up in single-user mode.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>To bring the system up to a multi-user configuration from the single-user
all you have to do is hit ^D on the console.  The system
will then execute /etc/rc,
a multi-user restart script (and /etc/rc.local),
and come up on the terminals listed as
active in the file /etc/ttys.<tt> </tt>
See
<i>init</i>(8)
and
<i>ttys</i>(5).<tt> </tt>
Note, however, that this does not cause a file system check to be performed.<tt> </tt>
Unless the system was taken down cleanly, you should run
``fsck'' or force a reboot with
<i>reboot</i>(8)
to have the disks checked.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>To take the system down to a single user state you can use
<dl><dt><dd>
<b>#</b> kill 1
<br>
</dl>
or use the
<i>shutdown</i>(8)
command (which is much more polite, if there are other users logged in.)
when you are up multi-user.<tt> </tt>
Either command will kill all processes and give you a shell on the console,
as if you had just booted.  File systems remain mounted after the
system is taken single-user.  If you wish to come up multi-user again, you
should do this by:
<dl><dt><dd>
<b>#</b> cd /
<br>
<b>#</b> umount -a
<br>
<b>#</b> ^D
<br>
</dl>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>Each system shutdown, crash, processor halt and reboot
is recorded in the file /usr/adm/shutdownlog
with the cause.<tt> </tt>
<h2>4.22.&#160;<tt> </tt>Device errors and diagnostics
</h2>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>When serious errors occur on peripherals or in the system, the system
prints a warning diagnostic on the console.<tt> </tt>
These messages are written to the kernel logger where they are retrieved
by <i>syslogd</i>(8) via <i>/dev/klog</i> - <i>dmesg</i>(8) is now
obsolete.  <i>dmesg</i>(8) is present in the distribution but no longer
used.  The message buffer is now 4kb in size and external to the kernel.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>Error messages printed by the devices in the system are described with the
drivers for the devices in section 4 of the programmer's manual.<tt> </tt>
Some drivers have been modified to use the kernel logger, others still
simply do printf statements.<tt> </tt>
If errors occur suggesting hardware problems, you should contact
your hardware support group or field service.  It is a good idea to
examine the error log files regularly
(e.g. with ``tail -r <i>/usr/adm/messages</i>'').<tt> </tt>
<h2>4.23.&#160;<tt> </tt>File system checks, backups and disaster recovery
</h2>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>Periodically (say every week or so in the absence of any problems)
and always (usually automatically) after a crash,
all the file systems should be checked for consistency by
<i>fsck</i>(8).<tt> </tt>
The procedures of
<i>reboot</i>(8)
should be used to get the system to a state where a file system
check can be performed manually or automatically.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>Dumping of the file systems should be done on a regular schedule,
since once the system is going it is easy to
become complacent.<tt> </tt>
Complete and incremental dumps are easily done with
<i>dump</i>(8).<tt> </tt>
You should arrange to do a towers-of-hanoi dump sequence; we tune
ours so that almost all files are dumped on two tapes and kept for at
least a week in most every case.  We take full dumps every month (and keep
these indefinitely).<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>More precisely, we have three sets of dump tapes: 10 daily tapes,
5 weekly sets of 2 tapes, and fresh sets of three tapes monthly.<tt> </tt>
We do daily dumps circularly on the daily tapes with sequence
`3 2 5 4 7 6 9 8 9 9 9 ...'.<tt> </tt>
Each weekly is a level 1 and the daily dump sequence level
restarts after each weekly dump.<tt> </tt>
Full dumps are level 0 and the daily sequence restarts after each full dump
also.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>Thus a typical dump sequence would be:
<br>
<pre>      tape name   level number	     date	opr   size
      ------------------------------------------------------
	FULL	       0	 Nov 24, 1979	jkf   137MB
	  D1	       3	 Nov 28, 1979	jkf   29MB
	  D2	       2	 Nov 29, 1979	rrh   34MB
	  D3	       5	 Nov 30, 1979	rrh   19MB
	  D4	       4	  Dec 1, 1979	rrh   22MB
	  W1	       1	  Dec 2, 1979	etc   40MB
	  D5	       3	  Dec 4, 1979	rrh   15MB
	  D6	       2	  Dec 5, 1979	jkf   25MB
	  D7	       5	  Dec 6, 1979	jkf   15MB
	  D8	       4	  Dec 7, 1979	rrh   19MB
	  W2	       1	  Dec 9, 1979	etc   118MB
	  D9	       3	 Dec 11, 1979	rrh   15MB
	 D10	       2	 Dec 12, 1979	rrh   26MB
	  D1	       5	 Dec 15, 1979	rrh   14MB
	  W3	       1	 Dec 17, 1979	etc   71MB
	  D2	       3	 Dec 18, 1979	etc   13MB
	FULL	       0	 Dec 22, 1979	etc   135MB
</pre>
Weekly dumps are done often enough that daily dumps always fit on one tape.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>Dumping of files by name is best done by
<i>tar</i>(1)
but the amount of data that can be moved in this way is limited
to a single tape.<tt> </tt>
Finally if there are enough drives entire
disks can be copied with
<i>dd</i>(1)
using the raw special files and an appropriate
blocking factor; the number of sectors per track is usually
a good value to use, consult <i>/etc/disktab</i>.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>It is desirable that full dumps of the root file system be
made regularly.  These dumps should be made in ``bootable`` format,
including the standalone programs mentioned back in chapter 2 (boot,
mkfs, restor and icheck).  This can easily be done by going to 
/sys/pdpstand and doing:
<dl><dt><dd>
make all
<br>
 ./maketape /dev/nrmtXX maketape.data
<br>
dump 0u /
<br>
</dl>
This is especially true when only one disk is available.<tt> </tt>
Then, if the
root file system is damaged by a hardware or software failure, you
can rebuild a workable disk doing a restore in the
same way that the initial root file system was created.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>Exhaustion of user-file space is certain to occur
now and then and may be managed with a combination of disc quotas
(the 4.3BSD disc quota system is available as a kernel configuration
option), threatening
messages of the day, and personal letters.<tt> </tt>
<h2>4.24.&#160;<tt> </tt>Moving file system data
</h2>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>If you have the equipment,
the best way to move a file system
is to dump it to magtape using
<i>dump</i>(8),
use
<i>newfs</i>(8)
to create the new file system,
and restore the tape, using <i>restor</i>(8).<tt> </tt>
If for some reason you don't want to use magtape,
dump accepts an argument telling where to put the dump;
you might use another disk.<tt> </tt>
Filesystems may also be moved by piping the output of a <i>tar</i>(1)
to another <i>tar</i>.<tt> </tt>
The <i>restor</i> program accesses the raw device, laying down
inodes and blocks in the same place they came from as recorded by dump.<tt> </tt>
Care must therefore be taken when restoring a dump into
a file system smaller than the original file system.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>If you have to shrink a file system or merge a file system into another,
existing one, the best bet is to use <i>tar</i>(1).<tt> </tt>
If you
are playing with the root file system and only have one drive,
the procedure is more complicated.<tt> </tt>
If the only drive is a Winchester disk, this procedure may not be used
without overwriting the existing root or another partition.<tt> </tt>
What you do is the following:
<dl>
<dt>1.<dd>
GET A SECOND PACK!!!!<tt> </tt>
<dt>2.<dd>
Dump the root file system to tape using
<i>dump</i>(8).<tt> </tt>
<dt>3.<dd>
Bring the system down and mount the new pack.<tt> </tt>
<dt>4.<dd>
Load the distribution tape and install the new
root file system as you did when first installing the system.<tt> </tt>
<dt>5.<dd>
Boot normally
using the newly created disk file system.<tt> </tt>
</dl>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>Note that if you add new disk
drivers they should also be added to the standalone system in
<i>/sys/pdpstand</i>.<tt> </tt>
If you change the disk partition tables the default disk partition tables
in <i>/etc/disktab</i> should be modified.<tt> </tt>
<h2>4.25.&#160;<tt> </tt>Recompiling and reinstalling system software
</h2>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>It is easy to regenerate the system, and it is a good
idea to try rebuilding pieces of the system to build confidence
in the procedures.<tt> </tt>
The system consists of two major parts:
the kernel itself (/sys) and the user programs
(/usr/src and subdirectories).<tt> </tt>
The major part of this is /usr/src.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>The three major libraries are the C library in /usr/src/lib/libc
and the FORTRAN libraries /usr/src/usr.lib/libI77 and
/usr/src/usr.lib/libF77.  In each
case the library is remade by changing into the corresponding directory
and doing
<dl><dt><dd>
<b>#</b> make
<br>
</dl>
and then installed by
<dl><dt><dd>
<b>#</b> make install
<br>
</dl>
Similar to the system,
<dl><dt><dd>
<b>#</b> make clean
<br>
</dl>
cleans up.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>The source for all other libraries is kept in subdirectories of
/usr/src/usr.lib; each has a makefile and can be recompiled by the above
recipe.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>If you look at /usr/src/Makefile, you will see that
you can recompile the entire system source with one command.<tt> </tt>
To recompile a specific program, find
out where the source resides with the <i>whereis</i>(1)
command, then change to that directory and remake it
with the makefile present in the directory.<tt> </tt>
For instance, to recompile ``date'', 
all one has to do is
<dl><dt><dd>
<b>#</b> whereis date
<br>
<b>date: /usr/src/bin/date.c /bin/date /usr/man/man1/date.1</b>
<br>
<b>#</b> cd /usr/src/bin
<br>
<b>#</b> make date
<br>
</dl>
this will create an unstriped version of the binary of ``date''
in the current directory.  To install the binary image, use the
install command as in
<dl><dt><dd>
<b>#</b> install -s date /bin/date
<br>
</dl>
The -s option will insure the installed version of date has
its symbol table stripped.  The install command should be used
instead of mv or cp as it understands how to install programs
even when the program is currently in use.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>If you wish to recompile and install all programs in a particular
target area you can override the default target by doing:
<dl><dt><dd>
<b>#</b> make
<br>
<b>#</b> make DESTDIR=<i>pathname</i> install
<br>
</dl>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>To regenerate all the system source you can do
<dl><dt><dd>
<b>#</b> cd /usr/src
<br>
<b>#</b> make
<br>
</dl>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>If you modify the C library, say to change a system call,
and want to rebuild and install everything from scratch you
have to be a little careful.<tt> </tt>
You must insure that the libraries are installed before the
remainder of the source, otherwise the loaded images will not
contain the new routine from the library.  The following
sequence will accomplish this.<tt> </tt>
<dl><dt><dd>
<b>#</b> cd /usr/src
<br>
<b>#</b> make clean
<br>
<b>#</b> make build
<br>
<b>#</b> make installsrc
<br>
</dl>
The first <i>make</i> removes any existing binaries in the source trees
to insure that everything is reloaded.<tt> </tt>
The next <i>make</i> compiles and installs the libraries and compilers,
then compiles the remainder of the sources.<tt> </tt>
The final line installs all of the commands not installed in the first phase.<tt> </tt>
This will take about 12 hours on a reasonably configured 11/44.<tt> </tt>
<h2>4.26.&#160;<tt> </tt>Making local modifications
</h2>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>/usr/new is used by default for the programs that constitute
the contributed software portion of the distribution but which may not
have man pages installed.<tt> </tt>
Locally written commands that aren't distributed (or whose man pages are
not up to date) are kept in /usr/src/local and their binaries are 
kept in /usr/local.  This allows /usr/bin, /usr/ucb,
and /bin to correspond to the distribution tape
People using /usr/local commands are made
aware that the programs may not be in the base system yet.<tt> </tt>
<h2>4.27.&#160;<tt> </tt>Accounting
</h2>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>UNIX optionally records two kinds of accounting information:
connect time accounting and process resource accounting.  The connect
time accounting information is stored in the file <i>/usr/adm/wtmp</i>, which
is summarized by the program
<i>ac</i>(8).<tt> </tt>
The process time accounting information is stored in the file
<i>/usr/adm/acct</i> after it is enabled by
<i>accton</i>(8),
and is analyzed and summarized by the program
<i>sa</i>(8).<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>If you need to recharge for computing time, you can develop
procedures based on the information provided by these commands.<tt> </tt>
A convenient way to do this is to give commands to the clock daemon
<i>cron
</i>to be executed every day at a specified time.  This is done by adding
lines to <i>/usr/adm/crontab</i>; see
<i>cron</i>(8)
for details.<tt> </tt>
<h2>4.28.&#160;<tt> </tt>Resource control
</h2>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>Resource control in 2.11BSD is more
elaborate than in previous PDP-11 UNIX systems.<tt> </tt>
The resources consumed
by any single process can be limited by the mechanisms of
<i>setrlimit</i>(2).  As distributed, the mechanism
is voluntary, though sites may choose to modify the login
mechanism to impose limits.  Csh now has the <i>limits</i>
builtin command enabled.  Another available option
is the 4.3BSD disc quota system.<tt> </tt>
<h2>4.29.&#160;<tt> </tt>Files that need periodic attention
</h2>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>The discussion of system operations is concluded by listing
the files that require periodic attention or are system specific
<pre>/etc/fstab		how disk partitions are used
/etc/disktab		disk partition sizes
/etc/printcap		printer data base
/etc/gettytab		terminal type definitions
/etc/remote		names and phone numbers of remote machines for tip(1)
/etc/group		group memberships
/etc/motd		message of the day
/etc/master.passwd	password file; each account has a line
/etc/rc.local		local system restart script; runs reboot; starts daemons
/etc/inetd.conf 	local internet servers
/etc/hosts		host name data base
/etc/networks		network name data base
/etc/netstart		Startup file to configure network
/etc/services		network services data base
/etc/hosts.equiv	hosts under same administrative control
/etc/syslog.conf	error log configuration for syslogd(8)
/etc/ttys		enables/disables ports
/etc/crontab		commands that are run periodically
/etc/aliases		mail forwarding and distribution groups
/usr/adm/acct		raw process account data
/usr/adm/messages	system error log
/usr/adm/shutdownlog	log of system reboots
/usr/adm/wtmp		login session accounting
</pre>
<!--  Copyright (c) 1980 Regents of the University of California. -->
<!--  All rights reserved.  The Berkeley software License Agreement -->
<!--  specifies the terms and conditions for redistribution. -->
<!-- 	@(#)a.t	2.1 (GTE) 1995/06/16 -->
<br>
<b>
</b><b><center>APPENDIX A - KERNEL CONFIGURATION OPTIONS
<br>
</center>
</b><b></b><p>
<p>
<b></b>
<h2>4.30.&#160;<tt> </tt>Kernel configuration options
</h2>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>The 2.11BSD kernel has a number of parameters and options that can be
used to tailor the kernel to site specific needs.<tt> </tt>
This appendix lists the parameters and options used in the kernel.  The
parameters have numeric values, usually table sizes.  The options flags
are either defined or undefined (via the values YES or NO respectively.)
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>Prototypes for all the following options can be found in the generic
kernel configuration file <i>/sys/conf/GENERIC</i>.  The process of configuring
a new kernel consists simply of copying the generic configuration
file to a new file, <i>SYSTEM</i> and then editing the options in
<i>SYSTEM</i> to reflect your needs.  You can treat the items copied from
GENERIC as a ``grocery list'', checking off those options you want,
crossing out those you don't and setting numeric parameters to reasonable
values.<tt> </tt>
<h2>4.31.&#160;<tt> </tt>Configuring the number of mountable file systems (NMOUNT)
</h2>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>Because of time constraints the
<b>NMOUNT
</b>constant was not moved into the kernel configuration file where it belongs.<tt> </tt>
<b>NMOUNT
</b>is used to configure the number of mountable file systems in 2.11BSD.  Since
each slot in the kernel mount table takes up close to a half Kb of
valuable kernel data space, the distribution kernel comes configured
with
<b>NMOUNT
</b>set to 5.<tt> </tt>
This is almost certainly too small for most sites and should be increased
to the number of file systems you expect to mount.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt><b>NMOUNT
</b>is defined in
<i>/sys/h/param.h</i>.<tt> </tt>
If you change its value, you must recompile the kernel (obviously) and the
following applications:
<i>mount</i>,
<i>quotaon</i>,
<i>edquota</i>,
<i>umount</i>,
and
<i>df</i>.<tt> </tt>
<h2>4.32.&#160;<tt> </tt>GENERIC kernel configuration
</h2>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>All of the generic kernels support the following devices:
<pre>Device				    Number
-
RK06/07 			      2
MSCP (RA) Controllers		      2
MSCP (RA) Disks 		      3
RL01/02 Drives			      2
SMD (XP) Controllers		      1
SMD (XP) Disks			      2
TE16, TU45, TU77 (HT) Tape drives     2
TM11 (TM) Tape drives		      2
TS11 (TS) Tape drives		      2
TK50 (TMSCP) Tape drives	      2
</pre>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>The generic kernel adapts automatically to the booted device.  The 'a'
partition on the booted device is automatically made the root filesystem
and the 'b' partition the swap area (except for the RL02 which uses the
second drive).  The size of the swap partition is determined at run
time, the kernel queries the driver for the number of block in the 'b'
partition.  <b>NOTE:</b> If the swap partition is not labeled as being
of type <i>swap</i> the kernel will panic.<tt> </tt>
<h2>4.32.1.&#160;<tt> </tt>GENERIC kernel configuration file
</h2>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt># Machine configuration file for 2.11BSD distributed kernel.
<br>
#
<br>
# Format:
<br>
#	name	value		comments
<br>
# An item's value may be either numerical, boolean or a string; if it's
<br>
# boolean, use "YES" or "NO" to set it or unset it, respectively.  Use
<br>
# the default value and the comments field as indicators of the type of
<br>
# field it is.
<br>

<br>
#########################################
<br>
# MACHINE DEPENDENT PARAMETERS		#
<br>
#########################################
<br>

<br>
# Machine type
<br>
# Split I/D and hardware floating point are required.
<br>
#
<br>
# Including UNIBUS map support for machines without a UNIBUS will not cause
<br>
# a kernel to die.  It simply includes code to support UNIBUS mapping if
<br>
# present.
<br>
#
<br>
# The define UNIBUS_MAP implements kernel support for UNIBUS mapped
<br>
# machines.  However, a kernel compiled with UNIBUS_MAP does *not* have to
<br>
# be run on a UNIBUS machine.  The define simply includes support for UNIBUS
<br>
# mapping if the kernel finds itself on a machine with UNIBUS mapping.
<br>
UNIBUS_MAP	YES			# include support for UNIBUS mapping
<br>

<br>
# The define Q22 has been removed.  The references to it were incorrect
<br>
# (i.e. using it to distinguish between an Emulex CS02 and a DH11) or
<br>
# inappropriate (the if_il.c driver should have been checking if a Unibus
<br>
# Map was present at runtime).
<br>

<br>
#LINEHZ		50		# clock frequency European
<br>
LINEHZ		60			# clock frequency USA
<br>

<br>
# PDP-11 machine type; allowable values are GENERIC, 44, 70, 73.  GENERIC 
<br>
# should only be used to build a distribution kernel.  The only use of this
<br>
# option is to select the proper in-line PS instructions (references to the
<br>
# PSW use 'spl', 'mfps/mtps' or 'movb' instructions depending on the cpu type).
<br>
PDP11		GENERIC		# distribution kernel
<br>
#PDP11		44			# PDP-11/44
<br>
#PDP11		70			# PDP-11/70,45,50,55
<br>
#PDP11		73			# PDP-11/73,53,83,93,84,94
<br>

<br>
#########################################
<br>
# GENERAL SYSTEM PARAMETERS		#
<br>
#########################################
<br>

<br>
IDENT		GENERIC			# machine name
<br>
MAXUSERS	4			# maxusers on machine
<br>

<br>
# BOOTDEV is the letter combination denoting the autoboot device,
<br>
# or NONE if not using the autoboot feature.
<br>
BOOTDEV		NONE		# don't autoboot
<br>
#BOOTDEV	dvhp			# DIVA Comp/V boot device
<br>
#BOOTDEV	hk6			# rk06 boot device
<br>
#BOOTDEV	hk7			# rk07 boot device
<br>
#BOOTDEV	ra			# MSCP boot device
<br>
#BOOTDEV	rl			# rl01/02 boot device
<br>
#BOOTDEV	rm			# rm02/03/05 boot device
<br>
#BOOTDEV	br			# Eaton BR1537/BR1711 boot device
<br>
#BOOTDEV	sc11			# Emulex SC11/B boot device
<br>
#BOOTDEV	sc21			# Emulex SC21 boot device
<br>
#BOOTDEV	si			# si 9500 boot device
<br>

<br>
# Timezone, in minutes west of GMT
<br>
#TIMEZONE	300			# EST
<br>
#TIMEZONE	360			# CST
<br>
#TIMEZONE	420			# WST
<br>
TIMEZONE	480			# PST
<br>
DST		1			# Daylight Savings Time (1 or 0)
<br>

<br>
# Filesystem configuration
<br>
# Rootdev, swapdev etc. should be in terms of makedev.  For example,
<br>
# if you have an SMD drive using the xp driver, rootdev would be xp0a,
<br>
# or "makedev(10,0)".  Swapdev would be the b partition, xp0b, or
<br>
# "makedev(10,1)".  The 10 is the major number of the device (the offset
<br>
# in the bdevsw table in conf.c) and the 0 and 1 are the minor numbers
<br>
# which correspond to the partitions as described in the section 4 manual
<br>
# pages.  You can also get the major numbers from the MAKEDEV script in
<br>
# /dev.
<br>
PIPEDEV		makedev(10,0)		# makedev(10,0) xp0a
<br>
ROOTDEV		makedev(10,0)		# makedev(10,0) xp0a
<br>
SWAPDEV		makedev(10,1)		# makedev(10,1) xp0b
<br>

<br>
# DUMPROUTINE indicates which dump routine should be used.  DUMPDEV
<br>
# should be in terms of makedev.  If DUMPDEV is NODEV no automatic
<br>
# dumps will be taken, and DUMPROUTINE needs to be set to "nulldev" to
<br>
# resolve the reference.  See param.h and ioconf.c for more information.
<br>
# DUMPLO should leave room for the kernel to start swapping without
<br>
# overwriting the dump.
<br>
DUMPLO		512			# dump start address
<br>
DUMPDEV		NODEV			# makedev(10,1) xp0b
<br>
DUMPROUTINE	nulldev			# no dump routine.
<br>
#DUMPROUTINE	hkdump			# hk driver dump routine
<br>
#DUMPROUTINE	hpdump			# hp driver dump routine
<br>
#DUMPROUTINE	radump			# ra driver dump routine
<br>
#DUMPROUTINE	rldump			# rl driver dump routine
<br>
#DUMPROUTINE	rmdump			# rm driver dump routine
<br>
#DUMPROUTINE	brdump			# br driver dump routine
<br>
#DUMPROUTINE	sidump			# si driver dump routine
<br>
#DUMPROUTINE	xpdump			# xp driver dump routine
<br>
#DUMPROUTINE	tmsdump			# tms driver dump routine
<br>

<br>
#########################################
<br>
# KERNEL CONFIGURATION			#
<br>
#########################################
<br>

<br>
BADSECT		NO		# bad-sector forwarding
<br>
EXTERNALITIMES	YES		# map out inode time values
<br>
UCB_CLIST	NO			# clists moved from kernel data space
<br>
NOKA5		NO			# KA5 not used except for buffers
<br>
					# and clists (_end &lt; 0120000);
<br>
QUOTA		NO			# dynamic file system quotas
<br>
					# NOTE -- *very* expensive
<br>

<br>
# UCB_METER is fairly expensive, but various programs (iostat, vmstat, etc)
<br>
# use it.
<br>
UCB_METER	NO			# vmstat performance metering
<br>

<br>
# NBUF is the size of the buffer cache, and is directly related to the UNIBUS
<br>
# mapping registers.  There are 32 total mapping registers, of which 30 are
<br>
# available.  The 0'th is used for CLISTS, and the 31st is used for the I/O
<br>
# page on some PDP's.  It's suggested that you allow 7 mapping registers
<br>
# per UNIBUS character device so that you can move 56K of data on each device
<br>
# simultaneously.  The rest should be assigned to the block buffer pool.  So,
<br>
# if you have a DR-11 and a TM-11, you would leave 14 unassigned for them and
<br>
# allocate 16 to the buffer pool.  Since each mapping register addresses 8
<br>
# buffers for a 1K file system, NBUF would be 128.  A possible exception would
<br>
# be to reduce the buffers to save on data space, as they were 24 bytes each
<br>
# Should be 'small' for GENERIC, so room for kernel + large program to run.
<br>
NBUF		32			# buffer cache, *must* be &lt;= 240
<br>

<br>
# DIAGNOSTIC does various run-time checks, some of which are pretty
<br>
# expensive and at a high priority.  Suggested use is when the kernel
<br>
# is crashing and you don't know why, otherwise run with it off.
<br>
DIAGNOSTIC	NO			# misc. diagnostic loops and checks
<br>

<br>
#########################################
<br>
# PERIPHERALS: DISK DRIVES		#
<br>
#########################################
<br>

<br>
NBR		0		# EATON BR1537/BR1711, BR1538A, B, C, D
<br>

<br>
NHK		2		# RK611, RK06/07
<br>

<br>
NRAC		1		# NRAD controllers
<br>
NRAD		2		# RX50, RC25, RD51/52/53, RA60/80/81
<br>

<br>
NRK		0		# RK05
<br>

<br>
NRL		2		# RL01/02
<br>

<br>
NRX		0		# RX02
<br>

<br>
NSI		0		# SI 9500 driver for CDC 9766 disks
<br>

<br>
# Because the disk drive type registers conflict with other DEC
<br>
# controllers, you cannot use XP_PROBE for the Ampex 9300 and
<br>
# Diva drives.  Read through /sys/pdpuba/hpreg.h and /sys/pdpuba/xp.c
<br>
# for information on how to initialize for these drives.
<br>
NXPC		1		# NXPD controllers (RH70/RH11 style)
<br>
NXPD		2		# RM02/03/05, RP04/05/06, CDC 9766,
<br>
				# Ampex 9300, Diva, Fuji 160, SI Eagle.
<br>
XP_PROBE	YES		# check drive types at boot
<br>

<br>
NRAM		0		# RAM disk size (512-byte blocks)
<br>

<br>
#########################################
<br>
# PERIPHERALS: TAPE DRIVES		#
<br>
#########################################
<br>

<br>
NHT		2		# TE16, TU45, TU77
<br>

<br>
# Setting AVIVTM configures the TM driver for the AVIV 800/1600/6250
<br>
# controller (the standard DEC TM only supports 800BPI).  For more details,
<br>
# see /sys/pdpuba/tm.c.
<br>
NTM		2		# TM11
<br>
AVIVTM		YES		# AVIV 800/1600/6250 controller
<br>

<br>
NTS		2		# TS11
<br>

<br>
NTMSCP		2		# TMSCP controllers
<br>
NTMS		2		# TMSCP drives
<br>
TMSCP_DEBUG	NO		# debugging code in TMSCP drive (EXPENSIVE)
<br>

<br>
#########################################
<br>
# PERIPHERALS: TERMINALS		#
<br>
#########################################
<br>

<br>
# NKL includes both KL11's and DL11's.
<br>
# It should always be at least 1, for the console.
<br>
NKL		1		# KL11, DL11
<br>
NDH		0		# DH11; NDH is in units of boards (16 each)
<br>
CS02		NO		# DH units above are really Emulex CS02 
<br>
				# boards on a 22bit Qbus.
<br>
NDM		0		# DM11; NDM is in units of boards (16 each)
<br>
NDHU		0		# DHU11
<br>
NDHV		0		# DHV11
<br>
NDZ		0		# DZ11; NDZ is in units of boards (8 each)
<br>

<br>
#########################################
<br>
# PERIPHERALS: OTHER			#
<br>
#########################################
<br>
NDN		0		# DN11 dialer
<br>
NLP		0		# Line Printer
<br>
LP_MAXCOL	132		# Maximum number of columns on line printers
<br>
NDR		0		# DR11-W
<br>

<br>
#########################################
<br>
# PSEUDO DEVICES, PROTOCOLS, NETWORKING	#
<br>
#########################################
<br>
# Networking only works with split I/D and SUPERVISOR space, i.e. with the
<br>
# 11/44/45/50/53/55/70/73/83/84.  NETHER should be non-zero for networking
<br>
# systems using any ethernet.  CHECKSTACK makes sure the networking stack
<br>
# pointer and the kernel stack pointer don't collide; it's fairly expensive
<br>
# at 4 extra instructions for EVERY function call AND return, always left
<br>
# NO unless doing serious debugging.
<br>
INET		NO		# TCP/IP
<br>
CHECKSTACK	NO		# Kernel &amp; Supervisor stack pointer checking
<br>
NETHER		0		# ether pseudo-device
<br>

<br>
# Note, PTY's and the select(2) system call do not require the kernel to
<br>
# be configured for networking (INET).  Note that you can allocate PTY's
<br>
# in any number (multiples of 8, of 16, even, odd, prime, whatever).  Nothing
<br>
# in the kernel cares.  PTY's cost 78 bytes apiece in kernel data space.  You
<br>
# should probably have at least 8-10 since several applications use them:
<br>
# script, jove, window, rlogin, ...
<br>
NPTY		0		# pseudo-terminals - GENERIC sys needs NONE
<br>

<br>
# To make the 3Com Ethernet board work correctly, splimp has to be promoted
<br>
# to spl6; splfix files that do this are in conf/3Com; the config script
<br>
# does the right thing.
<br>
NEC		0		# 3Com Ethernet
<br>
NDE		0		# DEUNA/DELUA
<br>
NIL		0		# Interlan Ethernet
<br>
NSL		0		# Serial Line IP
<br>
NQE		0		# DEQNA
<br>
NQT		0		# DEQTA (DELQA-YM, DELQA-PLUS)
<br>
NVV		0		# V2LNI (Pronet)
<br>
NACC		0		# ACC LH/DH ARPAnet IMP interface
<br>
PLI		NO		# LH/DH is connected to a PLI
<br>
NIMP		0		# ARPAnet IMP 1822 interface
<br>

<br>
# The following are untested in 2.11BSD; some are untested since before 2.9BSD
<br>
# Some won't even compile.  Most will require modification.  Good luck.
<br>
ENABLE34	NO		# if have the ENABLE34 board
<br>

<br>
NCSS		0		# DEC/CSS IMP11-A ARPAnet IMP interface
<br>
NDMC		0		# DMC11
<br>
NEN		0		# Xerox prototype (3 Mb) Ethernet
<br>
NHY		0		# Hyperchannel
<br>
NS		0		# Xerox NS (XNS)
<br>
NSRI		0		# SRI DR11c ARPAnet IMP
<br>
NTB		0		# RS232 interface for Genisco/Hitachi tablets
<br>

<br>
# Defining FPSIM to YES compiles a floating point simulator into the kernel
<br>
# which will catch floating point instruction traps from user space.  This
<br>
# doesn't work at present.
<br>
FPSIM		NO		# floating point simulator
<br>

<br>
# To enable profiling, the :splfix script must be changed to use spl6 instead
<br>
# of spl7 (see conf/:splfix.profile), also, you have to have a machine with a
<br>
# supervisor PAR/PDR pair, i.e. an 11/44/45/50/53/55/70/73/83/84, as well
<br>
# as both a KW11-L and a KW11-P.
<br>
#
<br>
# Note that profiling is not currently working.  We don't have any plans on
<br>
# fixing it, so this is essentially a non-supported feature.
<br>
PROFILE		NO		# system profiling with KW11P clock
<br>

<br>
INGRES		NO		# include the Ingres lock driver
<br>
<!-- 	Placed in the public domain June 17, 1995. -->
<!-- 	@(#)b.t	1.1 (2.11BSD) 1995/07/10 -->
<br>
<br>
<b>
<br>
<center>APPENDIX B - STANDALONE DISKLABEL PROGRAM
<br>
</center>
</b><b></b><p>
<p>
<b></b>
<h2>4.33.&#160;<tt> </tt>Standalone disklabel example
</h2>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>This is a real example of using the disklabel program to place a label
on a disk.  User input is in <b>bold</b> type.  The disklabel program was
loaded from a bootable TK50.  The disk being labeled in a RD54.  The BOOT&gt; 
prompt is from the 11/73 console ODT, if you are using an 11/44 the prompt 
will be &gt;&gt;&gt;.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>The first thing that is done is request disklabel to create a default
partition ('a') which spans the entire disk.  Some disk types have fixed
sizes and geometries, for example RK05 (rk), RK06/7 (hk) and RL02 (rl)
drives.  With this type of disk the standalone disklabel program will generate
a label with the correct geometry and 'a' partition size.  With MSCP ('ra') 
disks disklabel will query the controller for the information it needs.  The
last type of disk, SMD (xp), presents many problems, disklabel will attempt
to determine the drive type and geometry but you will have to verify the
information.<tt> </tt>
<p>
Indented paragraphs like this one are explanatory comments and 
are not part of the output from the disklabel program.  In the case of MSCP
drives the number of cylinders may be 1 too low.  This is discussed in the
example below.<tt> </tt>
<br>

<br>
BOOT&gt; <b>MU 0</b>
<br>

<br>
73Boot from tms(0,0,0) at 0174500
<br>
: <b>tms(0,1)</b>
<br>
Boot: bootdev=06001 bootcsr=0174500
<br>
disklabel
<br>
Disk? <b>ra(0,0)</b>
<br>
d(isplay) D(efault) m(odify) w(rite) q(uit)? <b>D</b>
<br>
d(isplay) D(efault) m(odify) w(rite) q(uit)? <b>d</b>
<br>

<br>
type: MSCP
<br>
disk: RD54
<br>
flags:
<br>
bytes/sector: 512
<br>
sectors/track: 17
<br>
tracks/cylinder: 15
<br>
sectors/cylinder: 255
<br>
cylinders: 1220
<br>
rpm: 3600
<br>
drivedata: 0 0 0 0 0
<br>

<br>
1 partitions:
<br>
#      size   offset   fstype   [fsize bsize]
<br>
  a: 311200 0 2.11BSD 1024 1024  # (Cyl. 0 - 1220*)
<br>

<br>
The columns do not line up nicely under the headings due to limitations
of the sprintf() routine in the standalone I/O package.  There is no
capability to justify the output.  It should be obvious which column
belongs under which heading.  The '*' says that the partition does not
end on a cylinder boundary.  This is due to the peculiar way in which
MSCP returns the geometry information:  sectors/track * tracks/cylinder *
cylinders != sectors per volume.<tt> </tt>
<p>
d(isplay) D(efault) m(odify) w(rite) q(uit)? <b>m</b>
<br>
modify
<br>
d(isplay) g(eometry) m(isc) p(artitions) q(uit)? <b>m</b>
<br>

<br>
It is normally not necessary to change the geometry of an MSCP disk.  On
the other hand it will almost always be necessary to specify the geometry
of an SMD drive (one which uses the XP driver).  Since the drive being
labeled is an MSCP drive the next step is to set the pack label to something
other than DEFAULT.<tt> </tt>
<br>

<br>
modify misc
<br>
d(isplay) t(ype) n(ame) l(able) f(lags) r(pm) D(rivedata) q(uit)? <b>l</b>
<br>
label [DEFAULT]: <b>TESTING</b>
<br>
modify misc
<br>
d(isplay) t(ype) n(ame) l(able) f(lags) r(pm) D(rivedata) q(uit)? <b>q</b>
<br>
modify
<br>
d(isplay) g(eometry) m(isc) p(artitions) q(uit)? <b>p</b>
<br>
modify partitions
<br>
d(isplay) n(umber) s(elect) q(uit)? <b>d</b>
<br>

<br>
type: MSCP
<br>
disk: RD54
<br>
flags:
<br>
bytes/sector: 512
<br>
sectors/track: 17
<br>
tracks/cylinder: 15
<br>
sectors/cylinder: 255
<br>
cylinders: 1220
<br>
rpm: 3600
<br>
drivedata: 0 0 0 0 0
<br>

<br>
1 partitions:
<br>
#      size   offset   fstype   [fsize bsize]
<br>
  a: 311200 0 2.11BSD 1024 1024  # (Cyl. 0 - 1220*)
<br>

<br>
modify partitions
<br>
d(isplay) n(umber) s(elect) q(uit)? <b>s</b>
<br>
a b c d e f g h q(uit)? <b>a</b>
<br>
sizes and offsets may be given as sectors, cylinders
<br>
or cylinders plus sectors: 6200, 32c, 19c10s respectively
<br>
modify partition 'a'
<br>
d(isplay) z(ero) t(ype) o(ffset) s(ize) f(rag) F(size) q(uit)? <b>s</b>
<br>
'a' size [311200]: <b>15884</b>
<br>
d(isplay) z(ero) t(ype) o(ffset) s(ize) f(rag) F(size) q(uit)? <b>q</b>
<br>
modify partitions
<br>
d(isplay) n(umber) s(elect) q(uit)? <b>s</b>
<br>
a b c d e f g h q(uit)? <b>b</b>
<br>
sizes and offsets may be given as sectors, cylinders
<br>
or cylinders plus sectors: 6200, 32c, 19c10s respectively
<br>
modify partition 'b'
<br>
d(isplay) z(ero) t(ype) o(ffset) s(ize) f(rag) F(size) q(uit)? <b>o</b>
<br>
'b' offset [0]: <b>15884</b>
<br>
modify partition 'b'
<br>
d(isplay) z(ero) t(ype) o(ffset) s(ize) f(rag) F(size) q(uit)? <b>s</b>
<br>
'b' size [0]: <b>16720</b>
<br>
modify partition 'b'
<br>
d(isplay) z(ero) t(ype) o(ffset) s(ize) f(rag) F(size) q(uit)? <b>t</b>
<br>
'b' fstype [unused]: <b>swap</b>
<br>
modify partition 'b'
<br>
d(isplay) z(ero) t(ype) o(ffset) s(ize) f(rag) F(size) q(uit)? <b>q</b>
<br>
modify partitions
<br>
d(isplay) n(umber) s(elect) q(uit)? <b>s</b>
<br>
a b c d e f g h q(uit)? <b>c</b>
<br>
sizes and offsets may be given as sectors, cylinders
<br>
or cylinders plus sectors: 6200, 32c, 19c10s respectively
<br>
modify partition 'c'
<br>
d(isplay) z(ero) t(ype) o(ffset) s(ize) f(rag) F(size) q(uit)? <b>o</b>
<br>
'c' offset [0]: <b>0</b>
<br>
modify partitions 'c'
<br>
d(isplay) z(ero) t(ype) o(ffset) s(ize) f(rag) F(size) q(uit)? <b>s</b>
<br>
'c' size [0]: <b>311200</b>
<br>
modify partitions 'c'
<br>
d(isplay) z(ero) t(ype) o(ffset) s(ize) f(rag) F(size) q(uit)? <b>t</b>
<br>
'c' fstype [unused]: <b>unused</b>
<br>
modify partitions 'c'
<br>
d(isplay) z(ero) t(ype) o(ffset) s(ize) f(rag) F(size) q(uit)? <b>q</b>
<br>
modify partitions
<br>
d(isplay) n(umber) s(elect) q(uit)? <b>s</b>
<br>
a b c d e f g h q(uit)? <b>g</b>
<br>
sizes and offsets may be given as sectors, cylinders
<br>
or cylinders plus sectors: 6200, 32c, 19c10s respectively
<br>
modify partition 'g'
<br>
d(isplay) z(ero) t(ype) o(ffset) s(ize) f(rag) F(size) q(uit)? <b>o</b>
<br>
'g' offset [0]: <b>32604</b>
<br>
modify partition 'g'
<br>
d(isplay) z(ero) t(ype) o(ffset) s(ize) f(rag) F(size) q(uit)? <b>s</b>
<br>
'g' size [0]: <b>278596</b>
<br>
modify partition 'g'
<br>
d(isplay) z(ero) t(ype) o(ffset) s(ize) f(rag) F(size) q(uit)? <b>t</b>
<br>
'g' fstype [unused]: <b>2.11BSD</b>
<br>
modify partition 'g'
<br>
d(isplay) z(ero) t(ype) o(ffset) s(ize) f(rag) F(size) q(uit)? <b>q</b>
<br>
modify partitions
<br>
d(isplay) n(umber) s(elect) q(uit)? <b>n</b>
<br>
Number of partitions (8 max) [7]? <b>7</b>
<br>
modify partitions
<br>
d(isplay) n(umber) s(elect) q(uit)? <b>q</b>
<br>
modify
<br>
d(isplay) g(eometry) m(isc) p(artitions) q(uit)? <b>d</b>
<br>

<br>
type: MSCP
<br>
disk: RD54
<br>
label: TESTING
<br>
flags:
<br>
bytes/sector: 512
<br>
sectors/track: 17
<br>
tracks/cylinder: 15
<br>
sectors/cylinder: 255
<br>
cylinders: 1220
<br>
rpm: 3600
<br>
drivedata: 0 0 0 0 0
<br>

<br>
7 partitions:
<br>
#      size   offset   fstype   [fsize bsize]
<br>
  a: 15884   0  2.11BSD 1024 1024  # (Cyl. 0 - 62*)
<br>
  b: 16720 15884 swap              # (Cyl. 62*- 127*)
<br>
  c: 311200  0   unused 1024 1024  # (Cyl. 0 - 1220*)
<br>
  g: 278596 32604 2.11BSD 1024 1024 # (Cyl. 127- 1220*)
<br>

<br>
modify
<br>
d(isplay) g(eometry) m(isc) p(artitions) q(uit)? <b>q</b>
<br>

<br>
On MSCP disks it is possible you will see a warning error like this:
<p>
partition c: extends past end of unit 0 311200 311100
<br>
partition g: extends past end of unit 32604 278596 311100
<p>
This is not cause for panic.  What this is saying is that the number of
cylinders is one too low.  MSCP devices do not necessarily use all of the
last cylinder.  The total number of blocks is precisely known for MSCP
devices  (it is returned in the act of bringing the drive online).  
However the number of sectors on the volume is not necessarily evenly
divisible by the number of sectors per track (311200 divided by 17*15 gives
1220.392).  Basically the last cylinder is not fully used.  What must be done
is raise the number of cylinders by 1.<tt> </tt>
<p>
<b>NOTE:</b> For any other disk type it is cause for concern if the warning
above is issued - it means that incorrect partition or geometry information
was entered by the user and needs to be corrected.<tt> </tt>
<p>
d(isplay) D(efault) m(odify) w(rite) q(uit)? <b>m</b>
<br>
modify
<br>
d(isplay) g(eometry) m(isc) p(artitions) q(uit)? <b>g</b>
<br>
modify geometry
<br>
d(isplay) s(ector/trk) t(rk/cyl) c(yl) S(ector/cyl) q(uit)? <b>c</b>
<br>
cylinders [1220]: <b>1221</b>
<br>
modify geometry
<br>
d(isplay) s(ector/trk) t(rk/cyl) c(yl) S(ector/cyl) q(uit)? <b>q</b>
<br>
modify
<br>
d(isplay) g(eometry) m(isc) p(artitions) q(uit)? <b>q</b>
<br>
d(isplay) D(efault) m(odify) w(rite) q(uit)? <b>w</b>
<br>
d(isplay) D(efault) m(odify) w(rite) q(uit)? <b>q</b>
<br>

<br>
73Boot from tms(0,0,1) at 0174500
<br>
: <b>ra(1,0,0)unix</b>
<br>
ra1 csr[00]: <b>0172154</b>
<br>

<br>
The last string entered shows how I boot from an alternate controller.  In
normal use, i.e. with a single MSCP controller, the string would simply
be <b>ra(0,0)unix</b>.<tt> </tt>
<h2>4.34.&#160;<tt> </tt>Standalone disklabel program
</h2>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>The standalone disklabel program is the second file on a boot tape (after
the bootblocks and boot program).  It is used to place an initial label
on a disk
describing the disk and its partitions.  The program is also used when the
root ('a') or swap ('b') partitions of a previously labeled system disk must
be modified.  The second use is mandated because the 
root and swap partitions can not be modified while the kernel has them
open.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt><i>disklabel</i> effectively runs in CBREAK mode - you do not need to
hit the RETURN key except when prompted for a multicharacter response
such as a string (the pack label) or a number (partition size).<tt> </tt>
Defaults are placed inside square brackets ([default]).   Entering 
RETURN accepts the default.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>The program is organized into several levels.  <i>disklabel</i> prints the
current level out before prompting.  At each level there is
always the choice of d(isplaying) the current label and q(uit)ing the current
level and returning to the previous level.  If you are at the top level
and enter <b>q</b> the program will exit back to <b>Boot</b> unless you have made
changes to the disklabel.  In that case you will be asked if you wish
to discard the changes, if you answer <b>y</b> the changes will be discarded.<tt> </tt>
If the answer is <b>n</b> the <b>q</b> is ignored and <i>disklabel</i> does
not exit.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>In the following paragraphs the convention is to <b>bold</b> the user input
while leaving the output from <i>disklabel</i> in normal type.  The devices
used were a TK50 and an RD54, thus the tape device is <b>tms</b> and the 
disk device is <b>ra</b>.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>The TK50 was booted resulting in the usual message from <b>Boot</b>:
<p>
73Boot from tms(0,0,0) at 0174500
<br>
: <b>tms(0,1)</b>
<h2>4.35.&#160;<tt> </tt>Disklabel - tour of the levels.<tt> </tt>
</h2>
<p>
Boot: bootdev=06001 bootcsr=0174500
<br>
disklabel
<br>
Disk? <b>ra(0,0)</b>
<br>
d(isplay) D(efault) m(odify) w(write) q(uit)? <b>m</b>
<p>
The 'D' option will request <i>disklabel</i> to create a default label based
on what the program can determine about the drive.  For some devices, such
as RL01/02, RK06/07, MSCP (RD54, RA81, usw.), <i>disklabel</i> can
determine what the drive type is and how many sectors it has.  For other 
devices, such as SMD drives supported by the <b>xp</b> driver, the task is 
complicated by the number of different controllers and emulations supported.<tt> </tt>
Some 3rd party controllers have capabilities that DEC controllers do not and
the <b>xp</b> has no way of knowing exactly which type of controller is
present.  In this case <i>disklabel</i> will <b>guess</b> and then depend on
you to enter the correct data.<tt> </tt>
<br>
<p>
modify
<br>
d(isplay) g(eometry) m(isc) p(artitions) q(uit)? <b>g</b>
<br>
modify geometry
<br>
d(isplay) s(ector/trk) t(rk/cyl) c(yl) S(ector/cyl) q(uit)? <b>q</b>
<p>
The Sector/cyl entry is rarely used.  <i>disklabel</i> will calculate
this quantity for you from the sector/trk and trk/cyl quantities.<tt> </tt>
<br>
<p>
modify
<br>
d(isplay) g(eometry) m(isc) p(artitions) q(uit)? <b>m</b>
<br>
d(isplay) t(ype) n(ame) l(abel) f(lags) r(pm) D(rivedata) q(quit)? <b>f</b>
<p>
Type is one of: SMD, MSCP, old DEC, SCSI, ESDI, ST506, floppy.<tt> </tt>
<p>
Name is a string up to 16 characters in length.  It is typically
something like <b>rd54</b> or <b>rm03</b> but may be any meaningful string.<tt> </tt>
<p>
Label is an arbitrary string up to 16 characters in length - nothing in 
the system checks for or depends on the contents of the pack label string.<tt> </tt>
<p>
Rpm is the rotational speed of the drive.  Nothing in the system uses
or depends on this at the present time.  Default is 3600.<tt> </tt>
<p>
Drivedata consists of 5 longwords of arbitrary data.  Reserved for future use.<tt> </tt>
<br>
<p>
modify misc flags
<br>
d(isplay) c(lear) e(cc) b(adsect) r(emovable) q(uit)? <b>q</b>
<p>
Ecc says that the controller/driver can correct errors.<tt> </tt>
<p>
Badsect indicates that the controller/driver supports bad sector replacement.<tt> </tt>
<p>
Removable indicates that the drive uses removable media (floppy, RL02,
RA60 for example).<tt> </tt>
<br>
<p>
modify misc
<br>
d(isplay) t(type) n(ame) l(abel) f(lags) r(pm) D(rivedata) q(uit)? <b>q</b>
<br>
modify
<br>
d(isplay) g(eometry) m(isc) p(artitions) q(uit)? <b>p</b>
<br>
modify partitions
<br>
d(isplay) n(umber) s(elect) q(uit)? <b>n</b>
<br>
Number of partitions (8 max) [7]? <b>7</b>
<p>
This is the highest partition number considered to be valid.<tt> </tt>
<i>disklabel</i> will adjust this parameter semi-automatically at the
<b>p</b> level but it may be necessary to use <b>n</b> in cases where
some partitions are not to be used or contain invalid information.<tt> </tt>
<br>
<p>
modify partitions
<br>
d(isplay) n(umber) s(elect) q(uit)? <b>s</b>
<br>
a b c d e f g h q(uit)? <b>a</b>
<br>
sizes and offsets may be given as sectors, cylinders
<br>
or cylinders plus sectors:  6200, 32c, 19c10 respectively
<br>
modify partition 'a'
<br>
d(isplay) z(ero) t(ype) o(ffset) s(ize) f(rag) F(size) q(uit)? <b>q</b>
<p>
Zero clears the size and offset fields of a partition entry and sets the
filesystem type to <b>unused</b>.<tt> </tt>
<p>
Type is the filesystem type and of the possible choices only <b>2.11BSD</b>,
<b>swap</b> and <b>unused</b> make any sense to specify.<tt> </tt>
<p>
Offset is the number of sectors from the beginning of the disk at which the
partition starts.<tt> </tt>
<p>
Size is the number of sectors which the partition occupies.<tt> </tt>
<p>
Frag is the number of fragments a filesystem block can be broken into.<tt> </tt>
It is not presently used and should be left at the default of 1.<tt> </tt>
<p>
Fsize is the filesystem blocksize and should be left at the default of
1024.<tt> </tt>
<p>
modify partitions
<br>
d(isplay) n(umber) s(elect) q(uit)? <b>q</b>
<br>
modify
<br>
d(isplay) g(eometry) m(isc) p(artitions) q(uit)? <b>q</b>
<br>
d(isplay) D(efault) m(odify) w(write) q(uit)? <b>q</b>
<br>
Label changed.  Discard changes [y/n]? <b>y</b>
<br>
<p>
<p>
73Boot from tms(0,0,1) at 0174500
<h2>4.36.&#160;<tt> </tt>Disklabel - helpful hints and tips.<tt> </tt>
</h2>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>Define only those partitions you actually will use.  There is no need to
set up all 8 partitions.  Drives less than 200Mb probably will only have
3 partitions defined, 'a', 'b' and 'd' for /, swap and /usr respectively.<tt> </tt>
Remember to set the number of partitions.  Disklabel will attempt to do this
for you by keeping track of the highest partition you modify but this is
not foolproof.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>Do not define overlapping partitions unless you are sure what you are 
doing.  <i>disklabel</i> will warn you of overlapping partitions but will
not prohibit you from writing such a label to disk.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt>Remember that the prompt levels nest in <i>disklabel</i>.  It will be necessary
in several cases to enter multiple <b>q</b> commands to get back to the top
level.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt><b>IMPORTANT:
</b>Keep at least 1, preferably more,  bootable tape or floppy with 
<i>disklabel</i> on it present at all times.  If the label on a disk
ever becomes corrupted the kernel will be very unhappy and probably won't
boot.  If this happens you will need to boot the standalone <i>disklabel</i>
program and relabel the disk.  At least 2.11BSD provides a standalone 
<i>disklabel</i> - previous 4BSD systems which implemented disklabels did not
and the cold-start of those systems was painful indeed.<tt> </tt>
<p>
&#160;<tt> </tt>&#160;<tt> </tt>&#160;<tt> </tt><b>IMPORTANT:
</b>Write down in at least one place, and keep with the tape/floppy mentioned
above, the geometry and partition layout you assign to the disk.  The
<i>disklabel</i><i>(8) program should be used to produce a hardcopy of the
disklabel.<tt> </tt>
</i><h2>Footnotes</h2>
<p>
<dl>
<dt>\(ua<dd>
DEC, PDP-11, VAX, IDC, SBI, UNIBUS and MASSBUS are trademarks of
Digital Equipment Corporation.<tt> </tt>
<p>
<dt>***<dd>
UNIX is a Trademark of Bell Laboratories.<tt> </tt>
<p>
<dl>
<dt>\(ua<dd>
2.11BSD would probably only require a moderate amount of squeezing to
fit on machines with less memory, but it would also be very
unhappy about the prospect.<tt> </tt>
<p>
<dl>
<dt>\(ua<dd>
References of the form X(Y) mean the subsection named
X in section Y of the UNIX programmer's manual.<tt> </tt>
<p>
<dl>
<dt>\(ua<dd>
The number of records in each tape file are approximate
and do not necessarily correspond to the actual number on the tape.<tt> </tt>
<p>
<dl>
<dt>\(ua<dd>
<b>Note:</b> that while a tape file consists of a single data stream,
the distribution tape(s) have data structures in these files.<tt> </tt>
Although the first tape contains only 8 tape files, they comprise
several thousand UNIX files.<tt> </tt>
<dt><dd><p>
<b>Note:</b> The standalone tape drive unit number is specially encoded
to specify both unit number and tape density (BPI).  Most tape subsystems
either automatically adjust to tape density or have switches on the drives to
force the density to a particular setting, but for those which don't the
following density select mechanisms may be necessary.  The <b>ts</b> only
operates at 1600BPI, so there is no special unit density encoding.  The
<b>ht</b> will operate at either 800BPI or 1600BPI.  Units 0 through 3
corresponding to 800BPI, and Units 4 through 7 corresponding to 1600BPI
on drives 0 through 3 respectively.  The standard DEC <b>tm</b> only supports
800BPI (and hence can't be used with the 2.11BSD distribution tape),
but several widely used <b>tm</b> emulators support 1600BPI and even
6250BPI.  Units 0 through 3 corresponding to 800BPI, Units 4 through
7 corresponding to 1600BPI, and Units 8 through 11 corresponding to
6250BPI on drives 0 through 3 respectively.<tt> </tt>
<p>
<dl>
<dt>\(ua<dd>
<b>Note:</b> These instructions have changed quite a bit during the
evolution of the system from 2.10.1BSD.  Previously,
if the disk on which you are creating a root file system was an <b>xp</b>
disk you would have been asked to check the drive type register and possibly
halt the processor to patch a location (hopefully before the driver 
accessed the drive).  <b>This is no longer needed</b>.<tt> </tt>
All geometry and partition information is obtained from the disklabel
created in step 2.<tt> </tt>
We also used to give tables of <b>m</b> and <b>n</b> values for various
disks, which are now purposely omitted.<tt> </tt>
<p>
<dl>
<dt>\(ua<dd>
<b>Note:</b> Previously a lengthy table of partition names organized by
specific disk type was given.<tt> </tt>
With the introduction of disklabels this is no longer
necessary (or possible since each site can select whatever partitioning
scheme they desire).  In step 2 (creating the disklabel) a partition should
have been created for <i>/usr</i>.  If this was not done then it may be easier
to perform step 2 now than to use the more complex <i>disklabel</i>(8)
program and <i>ed</i>(1).<tt> </tt>
<p>
<dl>
<dt>\(ua<dd>
On the TK50 the remaining source is the 9th file on the cartridge.<tt> </tt>
<p>
<dl>
<dt>\(ua<dd>
Note: The resolver routines add about 5kb of text and 1kb of data
to each program.  Also, the resolver routines use more stack space
which may cause large programs to crash due to failure to extend the
stack area.<tt> </tt>
<p>
<dl>
<dt>\(ua<dd>
You must reboot your system before you can remove the /olddev directory.<tt> </tt>
<p>
<dl>
<dt>\(ua<dd>
note that non-separate systems are not currently supported
<p>
<dl>
<dt>***<dd>
on networked systems there are two images <i>unix</i>, and <i>netnix</i>.<tt> </tt>
<p>
<dl>
<dt>\(ua<dd>
Note also, that only a single swapping area is supported.  The
<i>swapon</i>(2) system call and multiple swapping areas have <b>not</b>
been implemented under 2.11BSD (yet.  no real need since enough other resources
are exhausted by the time a 4mb 11/73 needs additional swap space).<tt> </tt>
<p>
<dl>
<dt>\(ua<dd>
comsat and biff are only available under systems configured
for networking support.<tt> </tt>
<p>
<dl>
<dt>\(ua<dd>
The <i>uucp</i> included in this distribution is the result
of work by many people; we gratefully acknowledge their
contributions, but refrain from mentioning names in the 
interest of keeping this document current.<tt> </tt>
<p>
<dl>
<dt>\(ua<dd>
If you are unfamiliar with the Internet addressing structure, consult
``Address Mappings'', Internet RFC-796, J. Postel; available from
the Internet Network Information Center at SRI.<tt> </tt>
</body>
</html>
