








             SSeettttiinngg UUpp UUnniixx -- SSeevveenntthh EEddiittiioonn

                      _C_h_a_r_l_e_s _B_. _H_a_l_e_y
                     _D_e_n_n_i_s _M_. _R_i_t_c_h_i_e


     This  document  has  been updated to include additional
processor and peripheral device support , and other enhance-
ments incorporated in UNIX(R) version seven by the Unix Sys-
tems Engineering group at DIGITAL.  The addenda tape  (dated
12/2/80)  supplied with the standard Unix version seven dis-
tribution has been included on this tape  in  the  directory
/sys/addenda.    Most   of  the  addenda  has  already  been
installed on this distribution, for more  detail  about  the
addenda see /sys/addenda/README.



                    Unix/v7m Release 2.1


                        Fred Canter
                        Bill Shannon
                       Jerry Brenner
                      Armando Stettner



     Digital  Equipment Corporation assumes no responsibili-
ties for this software and makes no warranties or guaranties
as to its suitability or completeness.





























                             -2-


     If  you  are  set  up to do it, it might be a good idea
immediately to make a copy of the tape to guard against dis-
aster.  The tape is 9-track 800 BPI or 1600 BPI and contains
some 512-byte records followed by many  10240-byte  records.
There are interspersed tapemarks.

     The system as distributed contains binary images of the
system and all the user level programs,  along  with  source
and  manual  sections for them--about 2100 files altogether.
The binary images, along with other things needed  to  flesh
out  the  file system enough so UNIX will run, are to be put
on one file system called the `root file system'.  The  file
system size required is 9600 blocks.  The second file system
contains the system sources,  needed  to  rebuild  Unix  and
requires  about 5000 512-byte blocks.  The third file system
has the remainder of the sources and all of  the  documenta-
tion, it requires 20,000 blocks of storage.

MMaakkiinngg aa DDiisskk FFrroomm TTaappee

     Perform  the  following bootstrap procedure to obtain a
disk with a root file system on it.

1.   Mount the magtape on drive 0 at load point.

2.   Mount a formatted disk pack on drive 0.
     In some cases a disk pack must also be mounted on drive
     1.

3.   Use  the  DEC  hardware boot ROM or other means to load
     block 0 or 1 at 800 or 1600 BPI  into  location  0  and
     transfer to 0.

4.   The tape should move and the CPU loop.

5.   The console should type

          _B_o_o_t
          _:

     Copy  the  magtape  to disk by the following procedure.
     The machine's printouts are shown in "  ",  explanatory
     comments  are within ( ).  Terminate each line you type
     by carriage  return  or  line-feed.   There  are  three
     classes  of  tape drives: the name `tm' is used for the
     TU10 or TE10, `ts' is used for the TS11,  and  `ht'  is
     used for the TU16 or TE16.  There are also four classes
     of disks: `rp' is used for the RP03, `hp' is  used  for
     the  RM02/3  and  the  RP04/5/6,  `hk'  is used for the
     RK06/7 , and `rl' is used for the RL02.













                             -3-


     If you should make a mistake while typing, the  charac-
ter  '#' erases the last character typed up to the beginning
of the line, and the character '@' erases  the  entire  line
typed.   Some  consoles  cannot  print  lower  case letters,
adjust the instructions accordingly.

     (bring in the program mkfs)
     ":" tm(0,3)    (`tm(0,3)' for TU10/TE10 800 BPI)
               (`ht(0,3)' for TU16/TE16 800 BPI)
               (`ht(4,3)' for TU16/TE16 1600 BPI)
               (`ts(0,3)' for TS11 1600 BPI)
               (`ts(6,3)' for TS11 1600 BPI `tstm')

     "file system size:" 9600 (9600 for RP03)
                    (9600 for RM02/3, RP04/5/6)
                    (9600 for RK06/7)
                    (7240 for RL01)
                    (16480 for RL02)

     (see Table 1, in Disk Layout below, for values of `m' and `n')
     "interleave factor:" m

     "blocks per cylinder:" n

     "file system:" rp(0,0)   (`rp(0,0)' for RP03)
                    (`hp(0,0)' for RM02/3, RP04/5/6)
                    (`hm(0,0)' for hp on second RH)
                    (`hk(0,0)' for RK06/7)
                    (`rl(0,0)' for RL01/2)
     _"_i_s_i_z_e _= _X_X_"
     _"_m_/_n _= _X_X_"
     (after a while)
     _"_e_x_i_t _c_a_l_l_e_d_"
     _"_B_o_o_t_"
     _"_:_"

The above step makes an empty file system.


























                             -4-


6.   The next thing to do is to restore the  data  onto  the
     new  empty  file  system. To do this you respond to the
     `:' printed in the last step with

          (bring in the program restor)
          ":" tm(0,4)    (`tm(0,4)' for TU10/TE10 800 BPI)
                    (`ht(0,4)' for TU16/TE16 800 BPI)
                    (`ht(4,4)' for TU16/TE16 1600 BPI)
                    (`ts(0,4)' for TS11 1600 BPI)
                    (`ts(6,4)' for TS11 1600 BPI `tstm')

          "tape?" tm(0,5)     (`tm(0,5)' for TU10/TE10 800 BPI)
                    (`ht(0,5)' for TU16/TE16 800 BPI)
                    (`ht(4,5)' for TU16/TE16 1600 BPI)
                    (`ts(0,5)' for TS11 1600 BPI)
                    (`ts(6,5)' for TS11 1600 BPI `tstm')

          "disk?" rp(0,0)     (`rp(0,0)' for RP03)
                    (`hp(0,0)' for RM02/3, RP04/5/6)
                    (`hm(0,0)' for hp on second RH)
                    (`hk(0,0)' for RK06/7)
                    (`rl(0,0)' for RL01/2)
          "Last chance before scribbling on disk." (you type return)
          (the tape moves, perhaps 5-10 minutes pass)
          "end of tape"
          _"_B_o_o_t_"
          _"_:_"

     You now have a UNIX root file system.


































                             -5-


BBoooottiinngg UUNNIIXX

     You probably have the bootstrap running, left over from
the  last  step above; if not, repeat the boot process (step
3) again.  The root file system  contains  18  preconfigured
unix  operating systems.  These unix systems are named `xyu-
nix', where `x' is the disk name and `y' is the  tape  name.
Boot  the  unix monitor which most closely matches your con-
figuration by responding to the ":" with one of the  follow-
ing:

     hp(0,0)hphtunix          (for RP04/5/6 or RM02/3,)
     hp(0,0)hptmunix          (on first RH controller)
     hp(0,0)hptsunix
     hm(0,0)hmhtunix          (for RP04/5/6 or RM02/3,)
     hm(0,0)hmtmunix          (on second RH controller)
     hm(0,0)hmtsunix
     rp(0,0)rphtunix          (for RP03)
     rp(0,0)rptmunix
     rp(0,0)rptsunix
     hk(0,0)hkhtunix          (for RK06/7)
     hk(0,0)hktmunix
     hk(0,0)hktsunix
     rl(0,0)rl01htunix   (for RL01)
     rl(0,0)rl01tmunix
     rl(0,0)rl01tsunix
     rl(0,0)rl02htunix   (for RL02)
     rl(0,0)rl02tmunix
     rl(0,0)rl02tsunix

The machine should type the following:

     _u_n_i_x_/_v_7_m _2_._1

     _m_e_m _= _x_x_x
     _#

The  _m_e_m message gives the memory available to user programs
in bytes.

     After booting unix, the current  date  and  time  (date
(1)) must be set as follows:

     # date yymmddhhmm

i.e.

     # date 8108231300















                             -6-


     UNIX is now running, and the `UNIX Programmer's manual'
applies; references below of the form X(Y) mean the  subsec-
tion  named X in section Y of the manual.  If your processor
is one of the non-separate I & D space CPUs mentioned above,
you  must  use  the alternate version of several system com-
mands and the C object  code  optimizer.   If  required  the
alternate commands should be installed as follows:

     cd /bin
     cat makefile
     make cmd40     (non-separate I & D CPU)
     or
     make cmd70     (separate I & D CPU)
     cd /
     sync

The   system   is  distributed  with  the  `cmd70'  commands
installed.  The following commands will be replaced:

     adb
     dcheck
     dump
     dumpdir
     icheck
     ncheck
     restor
     tar

The above list represents the commands required  to  set  up
and  maintain  unix version seven on the smaller processors.
Most of the remaining commands will function  without  being
recompiled, however there will be certain commands that will
need to be recompiled and others that are too large to oper-
ate on non-separate I & D space CPUs.

     If  your  system  disk  is  the  RL01 or RL02, you must
select alternate `/etc/rc'  and  `/etc/checklist'  files  as
follows:

     cp /etc/rc_rl01 /etc/rc
     cp /etc/cl_rl01 /etc/checklist
     or
     cp /etc/rc_rl02 /etc/rc
     cp /etc/cl_rl02 /etc/checklist


     The `#' is the prompt from the Shell, and indicates you
are the super-user.  The user  name  of  the  super-user  is
`root'  if  you  should find yourself in multi-user mode and
need to log in; the login is `root', there is no password.













                             -7-


     To simplify your life later, copy the appropriate  ver-
sion  of the system as specified above to plain `unix.'  For
example, use cp (1) as follows if you have an RP03 disk  and
a TU16/TE16 tape:

     cp rphtunix unix

In the future, when you reboot, you can type just

     hp(0,0)unix

to  the `:' prompt.  (Choose appropriately among `hp', `rp',
`hk', `rl' , `ht', `tm', `ts' according to  your  configura-
tion).   After  selecting and copying the correct version of
unix, all of the remaining preconfigured unix systems should
be  removed  in order to free up space in the root file sys-
tem.  The appropriate preconfigured unix  system  should  be
retained  so that in case of disaster there will always be a
bootable unix system in the root.

     You now need to make some special file entries  in  the
dev  directory. These specify what sort of disk you are run-
ning on, what sort of tape drive you  have,  and  where  the
file systems are.  For simplicity, this recipe creates fixed
device names.  These names will be used below, and  some  of
them  are built into various programs, so they are most con-
venient.  However, the names do  not  always  represent  the
actual  major  and  minor  device in the manner suggested in
section 4 of the Programmer's Manual.   For  example,  `rp3'
will  be  used  for the name of the file system on which the
user file system is put, even though it might be on an  RP06
and  is  not  necessarily  logical  device  3.   Also,  this
sequence will put the user file  system  on  the  same  disk
drive  as  the root, which is not the best place if you have
more than one drive.  Thus the prescription below should  be
taken  only as one example of where to put things.  See also
the section on `Disk layout' below.


























                             -8-


     In any event, change to the dev directory (cd(1))  and,
if  you  like, examine and perhaps change the makefile there
(make (1)).

     cd /dev
     cat makefile

Then, use one of

     make rp03
     make rp04
     make rp05
     make rp06
     make rm02
     make rm03
     make rp04_2
     make rp05_2
     make rp06_2
     make rm02_2
     make rm03_2
     make rk06
     make rk07
     make rl01
     make rl02

depending on which disk you have.  Then, use one of

     make tm
     make ht
     make ts
     make tstm

depending on which tape you have.  The `_2'  lines  are  for
the  hp  disks  on  the second RH11 or RH70 controller.  The
`tstm' line is for the special case of having a TS11  and  a
TM11 on the same system.

     The  file  `rp0' refers to the root file system; `swap'
to the swap-space file system; `rp2' to  the  system  source
file  system;  'rp3'  to  the user file system.  The devices
`rrp0', 'rrp2', and `rrp3' are the  `raw'  versions  of  the
disks.   Also,  `mt0' is tape drive 0, at 800 BPI; `rmt0' is
the raw tape, on which large records can be read  and  writ-
ten;  `nrmt0'  is  raw  tape with the quirk that it does not
rewind on close, which is a subterfuge that  permits  multi-
file  tapes  to be handled.  `mt1', `rmt1', and `nrmt1' also
refer to tape drive 0, but at 1600 BPI.
















                             -9-


     Before anything further is done the bootstrap block  on
the  disk (block 0) should be filled in.  This is done using
one of the following commands:

     (RP03)
     dd if=/mdec/rpuboot of=/dev/rp0 count=1

     (RM02/3, RP04/5/6)
     dd if=/mdec/hpuboot of=/dev/rp0 count=1

     (RK06/7)
     dd if=/mdec/hkuboot of=/dev/rp0 count=1

     (RL01/2)
     dd if=/mdec/rluboot of=/dev/rp0 count=1

Now the DEC disk bootstraps are  usable.   See  Boot  Proce-
dures(8) for further information.

     The  system  sources  should  now be extracted from the
distribution tape by following the  procedure  shown  below,
again  the comments are enclosed in ( ).  The number follow-
ing the "mkfs" command is the size of the file system, which
differs  for  each  type  of disk.  The numbers `m' and `n',
following the size , are the file system interleave factors,
see  `Disk  Layout' table 1 to obtain the optimum values for
your system.

          (make an empty file system)
     /etc/mkfs /dev/rrp2 ##### m n (skip this if using RL02)
                  (07400 on RP03)
                  (08000 on RM02/3)
                  (08778 on RP04/5/6)
                  (08514 on RK06/7)
                  (10240 on RL01)
     /etc/mount /dev/rp2 /sys (skip this if using RL02)
     cd /sys
          (skip 6 files on the tape)
     dd if=/dev/nrmt0 of=/dev/null bs=20b files=6 ( 800 BPI)
     dd if=/dev/nrmt1 of=/dev/null bs=20b files=6 (1600 BPI)
          (extract the source files)
     tar40 xbf 20 /dev/rmt0   ( 800 BPI)
     tar40 xbf 20 /dev/rmt1   (1600 BPI)
     cd /
     sync
     /etc/umount /dev/rp2     (skip this step if using RL02)

















                            -10-


     The next thing to do is to extract the rest of the data
from  the  tape.   This  user file system is too large for a
single RL01 disk, it must be split  between  two  RL01  disk
packs.   There  is  no  set  procedure for accomplishing the
split, one suggestion would be to load the source  files  on
one pack, the documentation on the second pack and then fill
out each pack with the remainder of the files.  Comments are
enclosed  in ( ); don't type these.  The number in the first
command is the size of the file system; it  differs  between
RP03,  RM02/3, RP04/5, RP06 , RK06/7, and RL01/2.  Again see
`Disk Layout' table 1 for the values of `m' and `n'.

          (make an empty file system)
     /etc/mkfs /dev/rrp3 ###### m n
                  (055000 on RP03)
                  (105120 on RM02/3)
                  (144210 on RP04/5)
                  (313082 on RP06)
                  (010240 on RL01)
                  (020480 on RL02)
                  (027060 on RK06)
                  (026598 on RK07)
     (The above command takes about 2-3 minutes on an RP03)
     /etc/mount /dev/rp3 /usr
     cd /usr
          (skip 7 files on the tape)
     dd if=/dev/nrmt0 of=/dev/null bs=20b files=7 ( 800 BPI)
     dd if=/dev/nrmt1 of=/dev/null bs=20b files=7 (1600 BPI)
          (extract the files)
     tar40 xbf 20 /dev/rmt0   ( 800 BPI)
     tar40 xbf 20 /dev/rmt1   (1600 BPI)
     (This takes a while, time for a break !)
     cd /
     sync
     /etc/umount /dev/rp3

All of the data on the tape has been extracted.

     You may at this point mount  the  source  file  systems
(mount(1)). To do this type the following:

     /etc/mount /dev/rp2 /sys (skip this step if using RL02)
     /etc/mount /dev/rp3 /usr

The source and manual pages are now available in subdirecto-
ries of /usr and /sys.  The above mount  commands  are  only
needed  if you intend to play around with source on a single
user system, which is not necessary.  The file  systems  are
mounted  automatically when multi-user mode is entered, by a
command in the file /etc/rc. (See `Disk Layout' below).  The
system  should  now be placed into multi-user mode by typing
the control and d keys simultaneously (control d), some text
will be printed followed by the "login:" prompt.










                            -11-


     Before  UNIX  is turned up completely, a few configura-
tion dependent exercises must be performed.  At this  point,
it  would  be  wise  to  read all of the manuals (especially
`Regenerating System Software') and to augment this  reading
with hand to hand combat.  DO NOT !, proceed past this point
until you have read the  section  on  regenerating  UNIX  in
`Regenerating  System  Software'.  The `Setting Up Unix' and
the `Regenerating System Software' documents are located  in
/usr/doc  and  can  be printed by using one of the following
commands:

     nroff -mf setup
     nroff -mf regen


RReeccoonnffiigguurraattiioonn

     The  general  information  given  in  this  section  is
intended  to  document  the areas of the unix software which
require modification in order to tailor unix to the specific
system  configuration.   The  suggested procedure is to read
this section and then follow the step by  step  instructions
in the `UNIX' section of `Regenerating system Software'.

     The  first  step  is  to select the type of unix system
most appropriate to your CPU, there are three;  unix_id  for
the separate I & D space CPUs (PDP11/44, PDP11/45, PDP11/55,
& PDP11/70); unix_i for the non-separate I &  D  space  CPUs
(PDP11/23,   PDP11/24,   PDP11/34,  PDP11/40,  &  PDP11/60);
unix_ov the overlay text kernel for the non-separate I  &  D
space CPUs.  The size limitations of the unix_i kernel makes
its use as an actual unix  system  inappropriate,  its  only
purpose in life is to initially load unix from the distribu-
tion tape.  The overlay text unix kernel should be  used  as
the  multi-user  unix system on the non-separate I & D space
machines.

     The UNIX system running is configured to run on a  non-
separate  I  &  D  space CPU with the given disk and tape, a
console, and no other device.  This  is  certainly  not  the
correct configuration.  You will have to correct the config-
uration table to reflect the true state of your machine.





















                            -12-


     It is wise at this point to know how to  recompile  the
system.   Respond to the "login:" prompt with "sys" followed
by a return, there is no password. This will  log  you  into
the  system source account with a current directory of /sys.
Print (cat(1)) the file /sys/conf/makefile.   This  file  is
input  to  the program `make(1)' which if invoked with `make
all' will recompile all of the system source and install  it
in  the correct libraries.  The libraries supplied with this
distribution tape are up to date and need not be  recompiled
unless  changes  are  made  to  the system source code.  See
`Regenerating System Software' for instructions on recompil-
ing  individual  source  modules  and installing them in the
correct libraries.

     The file /sys/h/param.h contains the  parameters  which
determine  the  size of the various data spaces within unix.
There are two versions of this file,  /sys/h/param_ov.h  for
the  PDP11/23,  PDP11/24,  PDP11/34, PDP11/40, and PDP11/60,
and  /sys/h/param_id.h  for  the  PDP11/44,  PDP11/45,   and
PDP11/70. Prior to recompiling any of the system source code
the correct parameter file must be copied to  /sys/h/param.h
and to /usr/include/sys/param.h.  This is done automatically
by the makefiles and shell procedues which are provided  for
making unix.

     The  program  mkconf(1)  prepares files that describe a
given  configuration  (See  mkconf(1)).   In  the  /sys/conf
directory,  the 18 files xyconf were input to mkconf to pro-
duce the 18 versions of the system xyunix, "x" is  the  disk
type  (rp,  hp,  hm,  hk, rl01, or rl02) and "y" is the tape
(ht, tm, or ts).  Pick the appropriate one, copy it to unix-
conf,  and  edit  unixconf  to add lines describing your own
configuration.  (Remember the console typewriter is automat-
ically  included;  don't  count it in the kl specification.)
Then run mkconf; it will generate the files l.s  (trap  vec-
tors) c.c (configuration table), and mch0.s.  Take a careful
look at l.s to make sure that all the devices that you  have
are  assembled  in  the  correct interrupt vectors.  If your
configuration is non-standard, you will have to  modify  l.s
to fit your configuration.























                            -13-


     There  are  certain  magic  numbers  and  configuration
parameters imbedded in various device drivers that  you  may
want  to  change.   The  device addresses of each device are
defined in each driver.  In case you have  any  non-standard
device  addresses,  just  change  the address and recompile.
(The device drivers are in the directory /sys/dev.)

     The DZ11 driver is configured for two DZ11 (8 lines).

     The DC11 driver is set to run 4  lines.   This  can  be
changed in dc.c.

     The  DH11  driver  is  set to handle 1 DH11 with a full
complement of 16 lines.  If you have less, or more, you  may
want to edit dh.c.

     The DN11 driver will handle 4 DN's.  Edit dn.c.

     The DU11 driver can only handle a single DU.  This can-
not be easily changed.

     The KL/DL driver is set up to run a single DL11-A,  -B,
or  -C  (the console) and no DL11-E's.  To change this, edit
kl.c to have NKL11 reflect the total  number  of  DL11-ABC's
and  NDL11 to reflect the number of DL11-E's.  So far as the
driver is concerned, the difference between the  devices  is
their address.

     You  should  edit  of  the disk and tape drivers (rl.c,
rf.c, rk.c, rp.c, tm.c, tc.c, ts.c,  hk.c,  hp.c,  ht.c)  to
reflect  the number of disk and tape drives in your configu-
ration.  The big disk drivers (hk.c, rp.c,  and  hp.c)  have
partition  tables  in  them which you may want to experiment
with.

     After all the corrections have been made, use `make(1)'
to  recompile  the  system (or recompile individually if you
wish: use the makefile as a guide).  If you  compiled  indi-
vidually, say `make unix??' in the directory /sys/conf , the
?? is the CPU type, i.e., 23, 24, 34, 40, 60,  44,  45,  55,
70.   The  final  object  file will be named unix_ov for the
PDP11/23, PDP11/24,  PDP11/34,  PDP11/40,  and  PDP11/60  or
unix_id  for the PDP11/44, PDP11/45, PDP11/55, and PDP11/70.
This file should be moved to the root, and  then  booted  to
try  it  out.   It  is  best  to name it /nunix so as not to
destroy the working system until you're sure it  does  work.
See  Boot  Procedures(8) for a discussion of booting.  Note:
before  taking  the  system  down,  always  (!!)  perform  a
sync(1m) to force delayed output to the disk.














                            -14-


SSppeecciiaall FFiilleess

     Next  you must put in special files for the new devices
in the directory /dev using mknod(1).  Print the  configura-
tion  file  c.c  created  above.   This  is the major device
switch of each device class (block and character).  There is
one  line  for  each  device configured in your system and a
null line for place holding for those  devices  not  config-
ured.   The  essential  block  special  files were installed
above; for any new  devices,  the  major  device  number  is
selected  by  counting  the  line  number (from zero) of the
device's entry in the block configuration table.   Thus  the
first  entry in the table bdevsw would be major device zero.
This number is also printed in the  table  along  the  right
margin.

     The  minor  device  is the drive number, unit number or
partition as described under each device in section 4 of the
manual.  For tapes where the unit is dial selectable, a spe-
cial file may be made for each possible selection.  You  can
also add entries for other disk drives.

     In  reality,  device names are arbitrary. It is usually
convenient to have a  system  for  deriving  names,  but  it
doesn't have to be the one presented above.

     Some further notes on minor device numbers.  The hp and
hk drivers use the 0100 bit of the minor  device  number  to
indicate  whether  or not to interleave a file system across
more than one physical device. See hp(4) and hk(4) for  more
detail.   The  tm,  ts,  and  ht drivers use the 0200 bit to
indicate whether or not  to  rewind  the  tape  when  it  is
closed.  The 0100 bit indicates the density of the tape, set
for 800 BPI and cleared for 1600 BPI.  By  convention,  tape
special  files with the 0200 bit on have an `n' prepended to
their name, as  in  /dev/nmt0  or  /dev/nrmt1.   Again,  see
tm(4), ts(4) or ht(4).


























                            -15-


     The  naming  of  character  devices is similar to block
devices.  Here the names are even more arbitrary except that
devices  meant  to  be  used  for teletype access should (to
avoid confusion, no other reason) be named /dev/ttyX,  where
X  is some string (as in `00' or `library').  The files con-
sole, mem, kmem, and null are already correctly  configured.
The  makefile  in /dev can be used to make the special files
for the DZ11 and DH11 communications  multiplexers  as  fol-
lows:

     make tty_rm    (removes all tty special files)
     make dz#  (# = dz unit number)
     make dh#  (# = dh unit number)

Each dz11 unit handles 8 lines, and each dh11 unit 16 lines.
Prior to making the dz or dh special files the "tty_rm" make
command  should  be  executed in order to remove an existing
tty special files, the files "/dev/console"  and  "/dev/tty"
will not be removed.

     The  disk and magtape drivers provide a `raw' interface
to the device which provides direct transmission between the
user's  core  and  the  device and allows reading or writing
large records.  The raw device counts as a character device,
and should have the name of the corresponding standard block
special file with `r' prepended.  (The  `n'  for  no  rewind
tapes violates this rule.)  Thus the raw magtape files would
be called /dev/rmtX.  These special files should be made.

     When all the special  files  have  been  created,  care
should  be  taken  to  change the access modes (chmod(1)) on
these files to appropriate values (probably 600 or 644).































                            -16-


FFllooaattiinngg PPooiinntt

     UNIX only supports (and really  expects  to  have)  the
FP11  type  floating  point  unit.   The  PDP11/40  Floating
Instruction Set is NOT  supported  by  unix.   For  machines
without the FP11 hardware, there is a user subroutine avail-
able that will catch illegal instruction traps and interpret
floating point operations.  This allows programs with float-
ing point constants to be compiled and executed, on machines
without  the  FP11.   To compile floating point programs use
the `-f' flag to cc(1). This flag ensures that the  floating
point  interpreter  is  loaded with the program and that the
floating point version of  `cc'  is  used.   The  system  as
delivered  has this code included in only the iostat (1) and
ac (1) commands and adb (1), although the  operating  system
adapts automatically to the presence or absence of the FP11.
If a  program  which  has  the  floating  point  interpreter
included is executed on a CPU with the FP11, the interpreter
code is ignored and the  floating  point  hardware  is  used
instead.  The floating point interpreter code may be removed
by recompiling the  program  without  the  -f  option.   The
floating  point simulator software is extremely slow, if any
serious floating point work is to be done the floating point
hardware is really required.

     The  changes  described  in the document "Unix Problems
With Floating-Point Processors" by Bob Campbell,  Ed  Gould,
Vance Vaughan, and Jim Reeds of the University of California
at Berkeley, have been installed in this distribution.


































                            -17-


TTiimmee CCoonnvveerrssiioonn

     If your machine is not in the Eastern  time  zone,  you
must  edit  (ed(1))  the file /sys/h/param.h to reflect your
local time.  The manifest `TIMEZONE' should  be  changed  to
reflect  the  time  difference between local time and GMT in
minutes.  For EST, this is 5*60; for PST it would  be  8*60.
Finally,  there  is  a  `DSTFLAG'  manifest; when it is 1 it
causes the time to shift to Daylight  Savings  automatically
between  the  last  Sundays  in  April and October (or other
algorithms in 1974 and 1975).  Normally this will  not  have
to  be  reset.   When the needed changes are done, recompile
and load the system using make(1) and  install  it.   (As  a
general  rule,  when  a  system  header file is changed, the
entire system should be recompiled.  As it happens, the only
uses  of  these  flags are in /sys/sys/sys4.c, so if this is
all that was changed it alone needs to be recompiled.)

     You   may   also   want   to   look   at    timezone(3)
(/usr/src/libc/gen/timezone.c)  to  see  if the name of your
timezone is in its internal  table.   If  needed,  edit  the
changes  in.   After timezone.c has been edited it should be
compiled   and   installed    in    its    library.     (See
/usr/src/libc/(mklib  and compall)) Then you should (at your
leisure) recompile and reinstall all programs  that  use  it
(such as date(1)).





































                            -18-


DDiisskk LLaayyoouutt

     The  following  table  lists the file system interleave
factors (m and n) to be used with mkfs (1m) and fsck -s (1m)
to  achieve  optimum free list spacing when creating or sal-
vaging file  systems.  These  values  were  derived  through
experimentation,  calculation  and  intuition,  and although
they may not be optimal in all cases they are certainly bet-
ter  that  the default free list spacing assumed by mkfs and
fsck.


                          TABLE 1

               File System Interleave Factors

  CPU     RL01/2  RK06/7  RP03    RM02    RM03    RP04/5/6
  TYPE     m/n     m/n     m/n     m/n     m/n     m/n

  11/23   13/20     X       X       X       X       X
  11/24   12/20   14/66     X     20/160    X     20/418
  11/34   10/20   11/66    6/200  15/160    X     15/418
  11/40   11/20   12/66    6/200  16/160    X     16/418
  11/44    7/20    8/66    4/200  11/160    X     11/418
  11/45    9/20   10/66    5/200  14/160    X     14/418
  11/45z  11/20   12/66     X     17/160    X     17/418
  11/55    9/20   10/66    5/200  14/160    X     14/418
  11/60    9/20   10/66    5/200  14/160    X     14/418
  11/70    6/20    6/66     X      9/160  13/160   9/418

     If there are to be more file systems mounted than  just
the root ,/sys, and /usr, use mkfs(1) to create any new file
system and put its mounting in the file /etc/rc (see init(8)
and  mount(1)).   (You  might  look at /etc/rc anyway to see
what has been provided for you.)

     There are two considerations in deciding how to  adjust
the  arrangement of things on your disks: the most important
is making sure there is adequate space for what is required;
secondarily,  throughput should be maximized.  Swap space is
a critical parameter.  The system as  distributed  has  8778
(hpunix),  8778  (hkunix),  8000 (rpunix) , 3000 (rl01unix),
4000 (rl02unix) blocks for swap space.  This should be large
enough  so  running out of swap space never occurs.  You may
want to change these if local wisdom indicates otherwise.


















                            -19-


     Many common system programs (C, the editor, the  assem-
bler etc.)  create intermediate files in the /tmp directory,
so the file system where this is stored also should be  made
large  enough  to accommodate most high-water marks.  If you
leave the root file system as distributed  (except  as  dis-
cussed  above) there should be no problem.  All the programs
that create files in /tmp take care to delete them, but most
are  not  immune  to events like being hung up upon, and can
leave dregs.  The directory  should  be  examined  every  so
often and the old files deleted.

     Exhaustion  of  user-file space is certain to occur now
and then; the only  mechanisms  for  controlling  this  phe-
nomenon are occasional use of du(1), df(1), quot(1), threat-
ening messages of the day, and personal letters.

     The efficiency with which UNIX is able to use  the  CPU
is  largely  dictated  by  the  configuration  of  disk con-
trollers.  For general time-sharing applications,  the  best
strategy  is  to try to split user files, the root directory
(including the /tmp directory) and the swap area among three
controllers.

     Once  you  have  decided  how  to make best use of your
hardware, the question is how to initialize it.  If you have
the equipment, the best way to move a file system is to dump
it (dump(1)) to magtape, use mkfs(1) to create the new  file
system,  and restore (restor(1)) the tape.  If for some rea-
son you don't want to use magtape, dump accepts an  argument
telling  where  to put the dump; you might use another disk.
Sometimes a file system has to be increased in logical  size
without  copying.   The super-block of the device has a word
giving the highest address which can be allocated.  For rel-
atively  small increases, this word can be patched using the
debugger (adb(1)) and  the  free  list  reconstructed  using
icheck(1).  The size should not be increased very greatly by
this technique,  however,  since  although  the  allocatable
space  will  increase  the  maximum number of files will not
(that is, the i-list  size  can't  be  changed).   Read  and
understand  the  description  given in file system(5) before
playing around in this way.  You may  want  to  see  section
rp(4)  or  hp(4)  for some suggestions on how to lay out the
information on RP disks.  More  detailed  information  about
the  disk partitions may be obtained from the `sizes' tables
in  the  disk  drivers  (hp.c,  hk.c,   rp.c).    Also   see
/usr/doc/hksizes  and  /usr/doc/hpsizes  for  the RK06/7 and
RM02/3, RP04/5/6 disk layouts.
















                            -20-


     If you have to merge a file system into another, exist-
ing  one, the best bet is to use tar(1).  If you must shrink
a file system, the best bet is  to  dump  the  original  and
restor  it onto the new filesystem.  However, this might not
work if the i-list on the smaller filesystem is smaller than
the  maximum  allocated inode on the larger.  If this is the
case, reconstruct the filesystem  from  scratch  on  another
filesystem  (perhaps using tar(1)) and then dump it.  If you
are playing with the root file  system  and  only  have  one
drive  the procedure is more complicated. What you do is the
following:

1.   GET A SECOND PACK!!!!

2.   Dump the current root filesystem (or the  reconstructed
     one) using dump(1).

3.   Bring the system down and mount the new pack.

4.   Retrieve the WECo distribution tape and perform steps 1
     through 5 at the beginning of this document, substitut-
     ing  the  desired file system size instead of 9600 when
     asked for `file system size'.

5.   Perform step 6 above up to the point where  the  `tape'
     question  is  asked.  At  this point mount the tape you
     made just a few minutes ago. Continue with step 6 above
     substituting a 0 (zero) for the 5.



































                            -21-


NNeeww UUsseerrss

     Install   new   users  by  editing  the  password  file
/etc/passwd (passwd(5)).  This procedure should be done once
multi-user  mode  is  entered (see init(8)).  You'll have to
make a current directory for each new user  and  change  its
owner  to  the  newly installed name.  Login as each user to
make sure the password file is correctly edited.  For  exam-
ple:

     ed /etc/passwd
     $a
     joe::10:1::/usr/joe:
     w
     q
     mkdir /usr/joe
     chown joe /usr/joe
     login joe
     ls -la
     login root

This  will  make  a  new  login entry for joe, who should be
encouraged to use passwd(1) to give himself a password.  His
default  current  directory  is /usr/joe which has been cre-
ated.  The delivered password file has the user _b_i_n in it to
be used as a prototype.





































                            -22-


MMuullttiippllee UUsseerrss

     If  UNIX  is  to  support simultaneous access from more
than just the console terminal, the file /etc/ttys (ttys(5))
has  to be edited.  To add a new terminal be sure the device
is configured and the special  file  exists,  then  set  the
first  character  of  the appropriate line of /etc/ttys to 1
(or add a new line).  If the new terminal is to be a "local"
terminal,  i.e.,  not a dialup line, set the first character
to 2, this will enable the terminal to operate without  hav-
ing  carriar  asserted.   Note  that  init.c will have to be
recompiled if there are to be more than 100 terminals.  Also
note  that  if  the  special  file is inaccessible when init
tries to create a process for it,  the  system  will  thrash
trying and retrying to open it.

FFiillee SSyysstteemm HHeeaalltthh

     Periodically  (say  every day or so) and always after a
crash, you should check all the file systems for consistency
(fsck  (1m)).   You  should create the file "/etc/checklist"
containing the names of the file systems to be checked,  see
fsck (1m) for more detail.  It is quite important to execute
sync (1m) before rebooting or taking the machine down.  This
is done automatically every 30 seconds by the update program
(8) when a multiple-user system is running, but  you  should
do it anyway to make sure.

     Dumping  of  the  file system should be done regularly,
since once the system is going it is  very  easy  to  become
complacent.   Complete and incremental dumps are easily done
with dump(1).  Dumping of files by  name  is  best  done  by
tar(1) but the number of files is somewhat limited.  Finally
if there are enough drives entire disks can be copied  using
cp(1),  or preferably with dd(1) using the raw special files
and an appropriate block size.



























                            -23-


CCoonnvveerrttiinngg SSiixxtthh EEddiittiioonn FFiilleessyysstteemmss

     The best way to convert file systems from  6th  edition
(V6) to 7th edition (V7) format is to use tar(1). However, a
special version of tar must be prepared to run on  V6.   The
following steps will do this:

1.   change directories to /usr/src/cmd/tar

2.   At the shell prompt respond

          make v6tar or make v6tar40

     This  will  leave an executable binary named `v6tar' or
     `v6tar40'.

3.   Mount a scratch tape.

4.   Use tp(1) to put `v6tar' on the scratch tape.

5.   Bring down V7 and bring up V6.

6.   Use tp (on V6) to read in `v6tar'. Put it  in  /bin  or
     /usr/bin (or perhaps some other preferred location).

7.   Use  v6tar  to  make tapes of all that you wish to con-
     vert.  You may want  to  read  the  manual  section  on
     tar(1)  to see whether you want to use blocking or not.
     Try to avoid  using  full  pathnames  when  making  the
     tapes.  This will simplify moving the hierarchy to some
     other place on V7 if desired. For example

          chdir /usr/ken
          v6tar c .

     is preferable to

          v6tar c /usr/ken


8.   After all of the desired tapes are made, bring down  V6
     and  reboot  V7.  Use  tar(1) to read in the tapes just
     made.




















                            -24-


OOddddss aanndd EEnnddss

     The programs dump, quot,  ncheck,  and  df  (source  in
/usr/source/cmd)  should  be changed to reflect your default
mounted file system devices.  Print the first few  lines  of
these  programs and the changes will be obvious.  Tar should
be changed to reflect your desired default tape drive.



                                        Good Luck

                                        Charles B. Haley
                                        Dennis M. Ritchie
                                        Fred Canter













































